var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 電腦輔助設計與實習 \n Repo:  https://github.com/mdecycu/cad2025 \n Web:  https://mde.tw/cad2025 \xa0(cad for computer aided design) \n 課程簡介: \n cad2025 課程將以每組至多六人分組進行，從繪圖範圍 20cm x 20cm 的\xa0 5-bar Linkage Plotter  與  Openduck mini \xa0零組件設計繪圖作為開端，各組成員可以自選 CAD 套件完成。其中 Plotter 驅動設計建議採用 NEMA 17 步進馬達 ( NEMA 17 Onshape ) 或自選伺服馬達進行設計繪圖，而 Openduck mini 驅動則建議採用\xa0 STS3215 磁編碼數位伺服機 \xa0( STS3215 Onshape )\xa0進行設計繪圖。 \n 5-bar Linkage Plotter  與  Openduck mini  零組件設計繪圖完成後，將設法利用  Webots  進行控制系統設計與動態模擬 (Dynamic Simulation)，課程最後將針對此兩項機電系統的實作進行規劃與討論。 \n 可攜程式套件: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n cad_data.7z  (包括 NX2312、Blender4.2 與 Webots2023b，4.2GB) \n 解開壓縮檔，將 nx、Webots_2023b 與 Blender 4.2 等目錄放入可攜系統的 data 目錄中。 \n 在命令列執行 webotsw 可啟動 Webots，設定 NX 使用授權後，執行 ugraf -nx 可啟動 NX2312。 \n Webots2023b 啟動時需要\xa0openssl_lh_set_thunks 函式，因為這是特別的 OpenSSL 介接，其目的可能是透過此函式與 OpenSSL 整合記憶體分配、除錯、或 OpenSSL 引擎擴充。 \n 目前已知 miniconda 中必須透過 conda install openssl=3.0.16 安裝舊版後的 openssl-3-x64.dll 中才會包含openssl_lh_set_thunks 函式。 \n Microsoft Visual C++ 可轉散發套件 \xa0( VC_redist.x64.exe ) \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n MS Teams 團隊代碼: wpv2s7j \n 課程評分: \n 學習心得報告 (60%)  - MS Teams 線上參與，6人一組每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 學習心得報告主題 : \n w3: 用什麼套件完成  5-bar Linkage Plotter  與  Openduck mini  零組件設計繪圖？  Solvespace ,  Siemens NX ,  Onshape  或其他？各有什麼優缺點？ ( plotter.7z ,  open_duck_mini.7z ) \n w7 ( 2a 採 Youtube 影片簡報 ):  5-bar Linkage Plotter  與  Openduck mini \xa0零組件設計繪製完成之後，如何切割零件? 為何要切割零件？ 如何利用  Webots  進行後續的控制系統設計與動態模擬 (Dynamic Simulation)？( plotter_project.7z ) \n w10:  Webots  是什麼？有什麼特點？ 如何進行場景模擬？ 如何用 Python 進行控制系統設計？ ( Tutorial ) \n w14:  Webots  的模型有沒有辦法用程式方法建立? 有沒有辦法直接從 CAD 套件中轉出  Webots  的場景模型？ \n w17: 如何實作一套  5-bar Linkage Plotter  與  Openduck mini ？( Disney Bipedal Robot ) \n w18: 課程總結 \n 個人與分組網站維護 (40%)  - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評 \n 實習項目: \n 如何維持教室整齊清潔? \n 學員定期打掃 (由助教安排)\xa0 \n 學員自律 \n 如何善用教室與工作站室硬體? \n 電腦設定 \n 網路連線 \n 課餘時間預約\xa0(由助教安排)\xa0 \n 5-bar Linkage Plotter  與  Openduck mini \xa0機電系統的設計模擬與製作規劃。 \n fivebar_parallel_linkage.7z  (in Solidworks and NX2312) \n plotter.7z \xa0(in Solvespace) \n 行事曆: \n 2a 上課時段: 每週五 13:20 - 16:10 (w5 10/10 國慶日放假, w7 10/24 光復節補假, w11 11/21 全校運動會) \n 2b 上課時段: 每週二 09:10 - 12:00 \n  全頁檢視  \n', 'tags': '', 'url': 'About.html'}, {'title': 'Mind-Map', 'text': '\n Edit cad2025.smm', 'tags': '', 'url': 'Mind-Map.html'}, {'title': 'AI', 'text': 'https://grok.com \xa0 \n https://chat.z.ai \xa0 \n https://chatgpt.com/ \xa0 \n https://github.com/copilot \xa0 \n https://gemini.google.com/app \xa0 \n \n 繪圖範圍 20cm x 20cm 的小型 5bar linkage plotter，你會建議 BOM 零組件規格如何? 請詳細說明原因。 \n https://www.feetechrc.com/products 中的各 motor 若要用在 5bar linkage plotter 專案, 選哪一個, 請詳細說明原因。 \n 希望實作 Openduck mini 專案，你會建議 BOM 零組件規格如何? 請詳細說明原因。 \n 5bar linkage plotter 參考 BOM: \n 採用步進馬達: \n \n 採用 STS3215: \n \n Openduck mini 參考 BOM: \n ST3215:\xa0 https://aifitlab.com/products/feetech-sts3215-servo-motor \xa0 \n \n \n \n 提問: \n 請以目前最具前瞻與權威的教育學者群觀點發言，說明機械設計相關科系的大二學生該如何學習「電腦輔助設計與實習」課程，並透過虛實整合，驗證機電資控制系統的可行性? \n 請就此一主題，建議學習步驟，並列出學生身分可以免費使用的工具。 \n 請就此一主題提供 15 則可以深入取得具體答覆的 AI 系統詢問句 \n 1. 請詳細說明大二學生在學習 Fusion 360 進行機械零件參數化建模時，應該掌握的核心技能有哪些？ 2. 如何利用 Onshape 教育版進行團隊協作設計，並確保版本控制與設計一致性？ 3. 請列出 FreeCAD 中適合初學者進行機械運動學模擬的模組及使用步驟。 4. 在機械設計課程中，使用 Fusion 360 的 Motion Study 功能進行連桿機構運動模擬，該如何設定拘束條件？ 5. 請解釋 Webots 如何整合機械模型與控制程式，並用具體範例說明 PID 控制在其中的應用。 6. 如何用 Tinkercad Circuits 模擬一個包含光電感測器與伺服馬達的簡易自動門控制系統？ 7. 請比較 Scilab Xcos 與 MATLAB Simulink 在控制系統模擬上的優缺點，特別針對機電系統設計。 8. 學生如何利用 Wokwi Arduino 模擬環境有效測試多感測器控制系統的穩定性與反應速度？ 9. 請提供一個完整的機電系統設計專案案例，從 CAD 建模到控制系統模擬，再到 Webots 虛擬測試。 10. 針對學生免費使用的軟體資源，如何設計一套循序漸進的學習計畫，有效結合機械設計與控制系統？ 11. 如何使用 Fusion 360 與 Simscale 整合進行結構強度與熱傳模擬，以驗證機械設計的可靠性？ 12. 請詳細說明 Arduino IDE 與 PlatformIO 開發環境在控制系統軟體撰寫上的差異與選擇建議。 13. Webots 中如何設定真實物理參數（如摩擦力、慣性矩）來提升機器人運動模擬的準確度？ 14. 學生若無法取得實體機器人硬體，如何利用虛擬模擬工具達成機電系統整合的實作學習？ 15. 請介紹目前最適合機械設計系學生免費取得的線上課程或教學平台，針對 CAD 與機電整合控制系統教學。 \n', 'tags': '', 'url': 'AI.html'}, {'title': 'Teams', 'text': '建議各組先細分為兩小組，每一小組三人，由小組長利用  https://github.com/mdecycu/cad2025_hw \xa0作為 template，建立一個協同設計練習用的倉儲，名稱定為 "team" 之後，將小組中其他兩位組員設為 collaborators，然後利用 Github Pages 中的頁面內容整合，以及 Onshape 上的\xa0 5-bar Linkage Plotter \xa0及\xa0 Openduck mini \xa0零組件協同設計，作為練習標的。待所有組員都充分了解如何利用 Github 與 Onshape 進行協同設計後，再由組長在 Github Classroom 中建立小組團隊。 \n cmsimde_ai_1.txt \n 協同設計流程.txt \n https://mde.tw/cad_w1 \xa0 \n \n 本課程利用 Github Classroom 由各組組長建立 Team (團隊) 後，再由組員逐一加入團隊，每組最多 6 名組員。 \n 由於各組的網站是由 6 位組員協同編輯，因此其過程的專案描述如下: \n Prompt 1: \n 目前有一個專案，透過解析 config/content.htm 檔案中 HTML 的 <h1>、<h2>、<h3> 標籤來進行內容分頁，並以這些標題作為靜態網站中各頁面的標題。系統根據 <h1>、<h2>、<h3> 的層級順序，動態建立多層次的網站導覽選單 (menu)。 content.htm 的內容編輯採用 Python Flask 搭配 JavaScript 編輯器，讓使用者能在瀏覽器中即時編輯各層級頁面的內容。編輯完成後，透過 Python 程式將內容分頁並產生含多層次選單的靜態頁面，並存放於 content 目錄中。 針對此一網站，若由六名組員同步協同維護，組員可選擇在本地端啟動動態編輯環境完成內容修改及靜態頁面生成，或直接利用 GitHub Codespaces 進行雲端開發。請詳述並說明在此協同編輯流程中會使用的 Git 指令與使用情境，同時指導各組員應如何有效同步作業以確保版本一致與作業流暢。 \n Prompt 2: \n 此外，六名組員中有三人必須負責以 CAD 協同完成 「5-bar Linkage Plotter」 的設計，另三人則協同進行 「Openduck mini」 零組件的設計繪圖。六人在設計過程中需同步記錄系統開發歷程並共同維護網站內容，請提出詳細網站頁面架構的規劃建議，以及可用於協同設計的 CAD 系統，以利整合設計成果與技術文件。請用繁體中文詳細說明各組員在此電腦輔助設計工程中會分別使用的 git 指令與使用情境，並建議該如何兼顧零組件設計繪圖與網站內容整理。 \n Prompt 3: \n 請設定組員 A 負責開發零件 A 及其相關網頁內容，組員 B 負責執行任務 B，組員 C 則負責任務 C。三位組員將同步進行各自的零組件開發工作，並分別在開發過程透過多次 git 提交維護對應的頁面 A、B 與 C。請列出每位組員在開發過程中所需使用的 Git 指令及其使用情境，並詳細說明在三項任務各自完成後，由組員 A 負責將所有成果整合至 main 分支所需的完整 Git 操作流程。同時，也請詳細說明組員 B 與 C 在整個協作過程中所需執行的 Git 指令與步驟。 \n Prompt 4: \n StartFragment  A, B, C 三名組員若使用 Onshape 執行同步零組件繪圖, 該如何協同整合? EndFragment  \n 專案概述與協同維護流程建議 \n 一、專案概述 本專案透過解析 config/content.htm 檔案中的 HTML 標籤 <h1>、<h2> 及 <h3>，實現內容分頁功能。系統將這些標題作為靜態網站中各頁面的標題，並依據標題的層級順序，動態生成多層次的網站導覽選單（Menu），以提升使用者瀏覽體驗。 內容編輯採用 Python Flask 框架結合 JavaScript 編輯器，讓使用者能直接在瀏覽器中編輯各層級頁面內容。完成內容編輯後，系統透過 Python 程式將分頁資料轉換為帶有多層次選單的靜態網頁，並將生成的靜態頁面存放於 content 目錄中。 \n 二、協同維護環境 \n 為提升協作效率，六名組員可選擇： 在本地端啟動動態編輯環境，進行內容修改及靜態頁面生成。 直接利用 GitHub Codespaces 進行遠端雲端開發與協作。 \n 三、協同編輯與版本同步建議 \n 針對六人團隊的同步維護，建議採用以下工作流程： \n 版本控管 \n 使用 Git 進行版本管理，並採用分支（Branch）策略，每位組員於獨立分支上進行內容編輯，避免直接衝突。 \n 本地或雲端編輯 \n 組員可在本地端或 Codespaces 環境中，透過 Flask + JavaScript 編輯器進行內容更新，並執行 Python 程式生成靜態頁面以供預覽與測試。 \n 提交與合併流程 \n 編輯完成後，組員將修改提交至個人分支並推送至遠端倉庫，透過 Pull Request (PR) 進行代碼審核與合併，確保內容品質及版本一致。 \n 衝突管理與溝通協調 \n 由於多組員共同編輯相同檔案，需定期拉取主分支最新版本，及時解決合併衝突。團隊成員間應保持密切溝通，避免重複編輯同一內容區塊。 \n 自動化測試與部署 \n 可結合 CI/CD 工具，於 PR 流程中自動執行靜態網站生成及測試，確保產出結果符合預期，並自動部署至測試或正式環境。 \n 此工作流程能有效保障多名組員在分散開發環境下，協同完成內容維護與靜態頁面產出，提升團隊合作效率與網站品質。', 'tags': '', 'url': 'Teams.html'}, {'title': 'Prompts', 'text': '繪圖範圍 20cm x 20cm 的 5-bar Linkage Plotter, 各連桿的尺寸該如何規劃配置，請詳細說明。 \n plotter_ai_1.txt \n plotter_ai_1_1.py \n plotter_ai_1_2.py \n \n L0=26.00, L1=18.00, L2=18.00, L3=16.00, L4=16.00 \n 如何進行設計運算?包括正向運動分析與逆向運動分析。', 'tags': '', 'url': 'Prompts.html'}, {'title': 'Homework', 'text': 'HW1: \n 利用 NX2312、 Onshape 、Solvespace 或自選 CAD 套件繪製五連桿機構零組件。 \n 參考資料:\xa0 plotter.7z \xa0(in Solvespace) \n 利用 NX2312、 Onshape 、Solvespace 或自選 CAD 套件繪製 Openduck mini 系統零組件。 \n HW2: \n Webots 五連桿 plotter 機構模擬，可讀取任何 png 圖檔，利用 plotter 在其工作範圍完成外圍輪廓線條繪圖。 \n \n 參考資料:\xa0 plotter.7z \xa0(in Solvespace) \n \n \n plotter_project.7z \n Webots Openduck mini 系統動態模擬。 \n 參考資料:\xa0 Openduck mini \xa0 \n \n HW3: \n 五連桿 plotter 與 Openduck mini 機電系統實作規劃。 \n 參考資料:\xa0 plotter.7z \xa0(in Solvespace)', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW2', 'text': '一個五連桿平面機構，固定點 A 與 E 的座標分別為 (0, 0), (-50, 0), link1 從 A 點連接向 B 點長度, 為一個直角三角形的斜邊, 此三角形的長邊尺寸為 50, 短邊尺寸為 45, link2 從 B 點連接向 C 點, 長度為 110, link3 從 C 點連接向 D 點長度也是 110, 而最後 link4 從 D 點連接向 E 點 長度也是一個直角三角形的斜邊, 此三角形的長邊尺寸為 50, 短邊尺寸為 45。請問 link1 及 llink4 的長度分別為多少? 假設 A 點與 E 點分別裝設步進馬達, 其 A 點的旋轉角度是由其點右邊延伸水平線作為旋轉 0 度點，B 點起始點位於 X 軸上, 且旋轉方向為順時針方向, 而 E 點的旋轉角度則是由其點左邊延伸水平線作為旋轉 0 度點, D 點起始點也是位於 X 軸上, 且旋轉方向為逆時針方向旋轉, link1 的旋轉角度設為 theta1, 角度單位為 degree, 而 link4 的旋轉角度設為 theta2, 角度單位也是 degree, 請先利用此平面機構的兩個輸入角度作為函式的輸入變數, 用 link1 、link2、link3、link4 代表這四個連桿長度的符號名稱，且將此函數命名為 forward(theta1, theta2), 請利用正向運動學 (Forward Kinematics) 的方式，採符號運算法 (Symbolic Formulation)，利用 Python 的 sympy 模組, 讓 forward 函式的輸出為點 C 的 X 與 Y 座標。 請推導。 另外也請利用逆向運動學 (Inverse Kinematics) 的方式, 採符號運算法 (Symbolic Formulation)，利用 Python 的 sympy 模組, 讓 Inverse(C 點的 X 座標, C 點的 Y 座標) 函式的輸出為對應的 theta1 與 theta2 的轉角表示式。 請推導, 且各推導過程均列出機構各點的 floating point 座標點的位置. \n fivebar_robot_2d.slvs \n \n StartFragment  \n 利用畢氏定理計算 link1 與 link4 的長度： \n \\[\\sqrt{50^2 + 45^2} = \\sqrt{2500 + 2025} = \\sqrt{4525} \\approx 67.27\\] \n 因此定義如下: \n import sympy as sp\n\nL1 = L4 = sp.sqrt(45**2 + 50**2)  # ≈ 67.24\nL2 = 110\nL3 = 110 \n StartFragment  \n Forward Kinematics \n 目標是定義 forward(theta1, theta2) 輸出點 C 的 (x, y)。 \n 幾何分析 \n \n 點 A 為原點 (0, 0)，link1 由 A 旋轉 \\(\\theta_1\\) 延伸至點 B。 \n 點 E 座標為 (-50, 0)，link4 由 E 旋轉 \\(\\theta_2\\) 延伸至點 D。 \n B 與 D 透過兩段連桿（link2 與 link3）連接，經過點 C。 \n \n 先定義這些變數並推導 B、D、C 的位置。 \n forward 函式:\xa0 fivebar_forward.py \n import sympy as sp\n\n# 正向運動學：給定角度與長度，求 C 點（兩個構型）\ndef forward(theta1_deg, theta2_deg, l1, l2, l3, l4):\n    # 角度轉弧度，考慮旋轉方向\n    theta1 = -theta1_deg * sp.pi / 180             # A 點，順時針\n    theta2 = (180 + theta2_deg) * sp.pi / 180      # E 點，左水平方向起點，逆時針旋轉\n\n    # 固定點座標\n    Ax, Ay = 0, 0\n    Ex, Ey = -50, 0\n\n    # B, D 點位置\n    Bx = Ax + l1 * sp.cos(theta1)\n    By = Ay + l1 * sp.sin(theta1)\n    Dx = Ex + l4 * sp.cos(theta2)\n    Dy = Ey + l4 * sp.sin(theta2)\n\n    # 向量 BD\n    vec_x = Dx - Bx\n    vec_y = Dy - By\n    d = sp.sqrt(vec_x**2 + vec_y**2)\n\n    # 中點 M\n    Mx = (Bx + Dx) / 2\n    My = (By + Dy) / 2\n\n    # 高（從 M 垂直方向偏移）\n    try:\n        h = sp.sqrt(l2**2 - (d / 2)**2)\n    except:\n        raise ValueError("構型不可行：連桿無法形成三角形")\n\n    # 單位向量 u = BD / ||BD||\n    ux = vec_x / d\n    uy = vec_y / d\n\n    # 垂直向量（旋轉 90°）\n    vx = -uy\n    vy = ux\n\n    # C 點 1（上構型）\n    C1x = Mx + h * vx\n    C1y = My + h * vy\n\n    # C 點 2（下構型）\n    C2x = Mx - h * vx\n    C2y = My - h * vy\n\n    print("B 點座標:", float(Bx.evalf()), float(By.evalf()))\n    print("D 點座標:", float(Dx.evalf()), float(Dy.evalf()))\n    print("C 點 1（上構型）:", float(C1x.evalf()), float(C1y.evalf()))\n    print("C 點 2（下構型）:", float(C2x.evalf()), float(C2y.evalf()))\n\n    return (float(C1x.evalf()), float(C1y.evalf())), (float(C2x.evalf()), float(C2y.evalf()))\n    \nprint(forward(30, 45, 67.27, 110, 110, 67.27)) \n Inverse Kinematics:\xa0 fivebar_inverse.py \n 現在要從點 C 的座標反推出 \\(\\theta_1, \\theta_2\\)。這部分相當複雜，因為存在多組解，因此我們專注於符號推導步驟。 \n 幾何觀念 \n \n 給定 C 點座標，要反推出： \n B 點在以 A 為中心，半徑為 L1 的圓周上 \n D 點在以 E 為中心，半徑為 L4 的圓周上 \n B → C 與 D → C 分別長 L2, L3 \n 使用向量反推、餘弦定理與 atan2 組合來求解旋轉角。 \n \n Inverse Kinematics: \n StartFragment  EndFragment  \n # 逆向運動學：輸入 C 點位置與桿長，反推所有可能的角度組合\nimport sympy as sp\n\ndef inverse(cx_val, cy_val, l1_val, l2_val, l3_val, l4_val):\n    # 定義符號變數\n    Cx, Cy, L1, L2, L3, L4 = sp.symbols(\'Cx Cy L1 L2 L3 L4\', real=True)\n\n    # 固定點 A 與 E\n    Ax, Ay = 0, 0\n    Ex, Ey = -50, 0\n\n    # ========== θ₁（順時針，從 +X 起算） ==========\n    vec_A = sp.Matrix([Cx - Ax, Cy - Ay])\n    r1 = vec_A.norm()\n    angle_A = sp.atan2(vec_A[1], vec_A[0])\n    cos_alpha1 = (L1**2 + r1**2 - L2**2) / (2 * L1 * r1)\n    cos_alpha1 = sp.Max(-1, sp.Min(1, cos_alpha1))  # 保護 acos 領域\n    alpha1 = sp.acos(cos_alpha1)\n    theta1_a = -sp.deg(angle_A - alpha1)\n    theta1_b = -sp.deg(angle_A + alpha1)\n\n    # ========== θ₂（逆時針，從 –X 起算） ==========\n    vec_E = sp.Matrix([Cx - Ex, Cy - Ey])\n    r2 = vec_E.norm()\n    angle_E = sp.atan2(vec_E[1], vec_E[0])\n    cos_alpha2 = (L4**2 + r2**2 - L3**2) / (2 * L4 * r2)\n    cos_alpha2 = sp.Max(-1, sp.Min(1, cos_alpha2))  # 保護 acos 領域\n    alpha2 = sp.acos(cos_alpha2)\n    # 補回 forward 中的 +180°\n    theta2_a = sp.deg(angle_E - alpha2) - 180\n    theta2_b = sp.deg(angle_E + alpha2) - 180\n\n    # 數值代入\n    subs = {\n        Cx: cx_val,\n        Cy: cy_val,\n        L1: l1_val,\n        L2: l2_val,\n        L3: l3_val,\n        L4: l4_val\n    }\n\n    try:\n        θ1a = float(theta1_a.evalf(subs=subs))\n        θ1b = float(theta1_b.evalf(subs=subs))\n        θ2a = float(theta2_a.evalf(subs=subs))\n        θ2b = float(theta2_b.evalf(subs=subs))\n    except Exception as e:\n        return [f"發生錯誤：{e}"]\n        \n    def normalize(a):\n        return round(a % 360, 4)\n\n\n    # 組合所有可能構型角度\n    results = [\n        (normalize(θ1a), normalize(θ2a)),\n        (normalize(θ1a), normalize(θ2b)),\n        (normalize(θ1b), normalize(θ2a)),\n        (normalize(θ1b), normalize(θ2b)),\n    ]\n\n    return results\n    \nprint(inverse(-12.77, -117.63, 67.27, 110, 110, 67.27)) \n \n \n \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'Plotter', 'text': 'To determine the drawable workspace of the five-bar linkage mechanism described in the provided Webots controller code and to outline it with a green contour, we need to compute the reachable workspace of the end-effector (point C) based on the kinematic constraints of the mechanism. Then, we will generate the outer and inner boundary contours and instruct the plotter to trace these contours. Below is the step-by-step solution. \n \n Step 1: Understanding the Five-Bar Linkage and Workspace \n The five-bar linkage mechanism consists of two fixed points (A and E) and two actuated joints (θ1 and θ2) that control the positions of points B and D, respectively. Point C is the end-effector, determined by the intersection of two circles centered at B (radius L2) and D (radius L3). The mechanism parameters are: \n \n L1 = L4 = 0.1682 m  (lengths of the first and fourth links) \n L2 = L3 = 0.275 m  (lengths of the second and third links) \n A = [0.0625, 0.15] m  (fixed pivot for θ1) \n E = [-0.0625, 0.15] m  (fixed pivot for θ2) \n offset = 41.9872°  (affects the angle calculations) \n \n The workspace is the set of all possible positions of point C, constrained by the joint angles θ1 and θ2 (ranging from -180° to 180°) and the geometric constraints of the linkage. The workspace is typically an annulus-like region (a ring-shaped area) due to the fixed distances from A to B (L1), B to C (L2), E to D (L4), and D to C (L3). \n Step 2: Computing the Workspace Boundaries \n To find the workspace, we need to determine the outer and inner boundaries of the region where point C can exist. This involves: \n \n Outer boundary : The maximum extent of point C when the linkage is fully extended. \n Inner boundary : The minimum extent when the linkage is folded inward, subject to valid kinematic solutions. \n \n The workspace can be approximated by sampling the joint angles θ1 and θ2 over their range and computing the corresponding positions of point C using the forward kinematics function. The boundaries are traced by finding the extreme points (maximum and minimum radial distances from a reference point, e.g., the origin or the midpoint between A and E). \n Forward Kinematics Recap \n The  forward_kinematics(theta1_rad, theta2_rad)  function computes point C as follows: \n \n Point B :  B = A + L1 * [cos(θ1 + offset), -sin(θ1 + offset)] \n Point D :  D = E - L4 * [cos(θ2 + offset), sin(θ2 + offset)] \n Point C : The intersection of a circle centered at B with radius L2 and a circle centered at D with radius L3. The function selects the intersection with the smaller y-coordinate (elbow-down configuration). \n \n Workspace Boundary Calculation \n To trace the workspace boundaries: \n \n Outer boundary : Occurs when the linkage is fully extended, e.g., when B and C are aligned such that the distance from A to C is maximized (approximately L1 + L2 = 0.1682 + 0.275 = 0.4432 m). \n Inner boundary : Occurs when the linkage is folded, and the distance from A to C is minimized, subject to valid intersections between the circles at B and D. \n \n We can sample θ1 and θ2 over [-180°, 180°] with a fine grid (e.g., 360 points per angle) to compute all possible C points. The convex hull of these points approximates the outer boundary, while the inner boundary requires identifying configurations where the distance from a reference point (e.g., the origin) is minimized, often when the linkage is folded inward. \n To simplify, we assume the workspace is symmetric around the line connecting A and E (y = 0.15 m) due to the symmetry in L1 = L4 and L2 = L3. We compute the workspace by: \n \n Sampling θ1 and θ2 in increments (e.g., 5°). \n Computing C for each (θ1, θ2) pair using  forward_kinematics . \n Collecting valid C points (where intersections exist). \n Determining the outer and inner boundaries by finding the maximum and minimum radial distances from a reference point (e.g., the origin [0, 0]) for each angular direction. \n \n Step 3: Generating the Workspace Contours \n To generate the outer and inner contours: \n \n Outer contour : For each angle φ around the origin (0, 0), find the C point with the maximum radial distance |C| = sqrt(x² + y²). \n Inner contour : For each angle φ, find the C point with the minimum radial distance, ensuring valid kinematic solutions. \n \n The algorithm to compute the contours is as follows: \n \n Define a range of angles φ (0 to 360°, e.g., 360 points). \n For each φ, iterate over a grid of θ1 and θ2 values (e.g., 72 points each, 5° increments). \n Compute C for each (θ1, θ2) using  forward_kinematics . \n Calculate the radial distance |C| and the angle of C relative to the origin. \n Group C points by their angle φ (within a small tolerance, e.g., ±2.5°). \n Select the maximum (outer) and minimum (inner) |C| for each φ bin. \n Sort the points by φ to create smooth contours. \n \n Step 4: Plotting the Contours in Webots \n The provided code already includes a mechanism to draw a green line in Webots using an  IndexedLineSet . We will modify this to draw two separate contours (outer and inner) in green, ensuring they are closed loops if the workspace is continuous. \n Step 5: Sweeping the Contours with the Plotter \n To make the plotter trace the outer and inner contours: \n \n Use the  inverse_kinematics  function to compute (θ1, θ2) for each point on the outer and inner contours. \n Apply the same interpolation and control logic as in the original code to move the plotter along each contour sequentially. \n Ensure smooth transitions between points using linear interpolation in joint space, as done in the original code. \n \n Implementation \n Below is the modified code to compute the workspace boundaries, draw the green contours, and control the plotter to trace both contours. This code extends the original by adding workspace computation and contour tracing. \n', 'tags': '', 'url': 'Plotter.html'}, {'title': 'Topics', 'text': 'https://www.engineering.com/what-is-siemens-designcenter/ \xa0(有關現階段各家 CAD 公司所提供的中階與高階電腦輔助機械設計套件，以及 Siemsns 就未來 CAD 發展方向的描述) \n 2b: \n w1: 課程簡介、分組與每三週分組心得簡報規劃 \n 2a: \n w1: \n 5bar linkage Plotter 設計參考: \n https://github.com/mdecycu/Pentagonal_plotting_robot_repo \xa0 \n https://github.com/mdecycu/five_bar_linkage \xa0 \n https://github.com/mdecycu/Robot-Sketcher-5-bar-parallel-manipulator- \xa0 \n https://github.com/mdecycu/Inverse-Kinematics-Five-Bar \xa0 \n 5-Bar Linkage Kinematic Solver and Simulator.pdf \n 提筆設計: \n 整體機構以 Watts linkage 提升及下降 \n 整體機構以凸輪機構提升，以彈簧拉回下降 \n 筆座採電磁鐵上升，以彈簧拉回下降 \n 繪圖機構總成固定，繪圖區域升降 \n 採用其他設計，討論各種設計的優缺點 \n w2: \n 登入 Onshape 後，連線至  OpenDuck mini v2 官方 Onshape  後，以滑鼠左鍵點選畫面左上方的功能表，點選 Copy workspace 後，選擇 Document name，滑鼠點選 Copy document to 中的 Owned by me，再點選下方的 Open 後，就可以取得 OpenDuck workspace 的副本。 \n 各組組員請分別練習在 Solvespace、NX2312 與 Openshape 上進行零件繪圖與組立，其中將牽涉使用各不同套件的繪圖與組立指令，並且必須了解如何透過不同零組件檔案格式( STEP424 、 Parasolid 、 STL  等)進行轉檔。 \n \n Openduck mini v2 的 trunk_bottom (下軀幹) 組立，其中包括 roll_motor_bottom x 2 以及 STS3250 次組立 x 2。 cad2025_openduck_Mechanical_Parts_2.7z \n 接下來，請各組員設法將下軀幹兩側的 left_roll_to_pitch 以及 right_roll_to_pitch 零件組立後，分工進行  Webots Tutorial  後，設法將組立件轉進 Webots，並利用 Python 控制程式讓兩側的 roll_to_pitch 可以由 STS3250 進行驅動。 \n \n 電腦輔助設計室電腦硬體與網路使用介紹 \n C 槽硬碟為 SSD，網路協定可以自行決定使用 IPv4 或 IPv6 (若使用純 IPv6 則必須設定 Proxy 才能連結到 github.com 以及僅支援 IPv4 協定的網站)\xa0 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0wpv2s7j \n 下載可攜程式套件: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n cad_data.7z  (包括 NX2312、Blender4.2 與 Webots2023b，4.2GB) \n 解開壓縮檔，將 nx、Webots_2023b 與 Blender 4.2 等目錄放入可攜系統的 data 目錄中。 \n 在命令列執行 webotsw 可啟動 Webots，設定 NX 使用授權後，執行 ugraf -nx 可啟動 NX2312。 \n Webots2023b 啟動時需要\xa0openssl_lh_set_thunks 函式，因為這是特別的 OpenSSL 介接，其目的可能是透過此函式與 OpenSSL 整合記憶體分配、除錯、或 OpenSSL 引擎擴充。 \n 目前已知 miniconda 中必須透過 conda install openssl=3.0.16 安裝舊版後的 openssl-3-x64.dll 中才會包含openssl_lh_set_thunks 函式。 \n Microsoft Visual C++ 可轉散發套件 \xa0( VC_redist.x64.exe ) \n 1. 複習如何開啟可攜套件、關閉可攜套件 \n 尚未有 Github 帳號者，必須自行 建立 Github 帳號 \n 利用 Python 執行設計運算、組立件分割、控制機電系統並維護倉儲與網站內容 \n youbot_cart.7z \n 命令列中執行 webotsw 啟動 Webots \n 開啟 worlds 目錄中的 youbot_cart.wbt (執行控制程式後，以方向鍵控制 cart 移動) \n 開啟 worlds 目錄中的 youbot_cart_w_shooter.wbt (按 a 送球，按 m 擊球，按 k 退回) \n 說明如何建立分組倉儲 Template \n 2. 如何開啟 Solvespace、NX2312、Webots 與 Blender \n 利用 Solvespace、NX2312 或 Onshape 進行零組件繪圖 \n Solvespace Tutorial \n Learn Solvespace \n NX2312 Tutorial \n Onshape for Education \n 利用 Webots 建立機電模擬系統 ( User Guide ) \n Webots Tutorial \n 利用 Blender 檢視組立件分割結果 \n Blender Tutorial \n 3. Github Classroom 上的分組網站:  https://github.com/mdecad2025 \xa0 \n 各組組長建立 Github Classroom 分組團隊，取得分組倉儲\xa0 \n 4. 利用 Git 與 Github 進行協同設計 \n 各組員維護分組倉儲中的分支，進行協同設計 \n 熟悉 Pull Requests 或各組員開發分支與主分支的合併 \n 5. 平面五連桿機構零組件繪圖 \n Solvespace、NX2312 與 Onshape 的操作應用 \n 6. Webots 五連桿機構系統模擬 \n 零組件的 STL 與 OBJ 格式轉檔 \n Blender 的零組件檢視應用 \n Robot、Solid、Shape、CadShape、HingeJoint 與 device 節點的應用 \n Python Controller 程式的應用 \n 參考:\xa0 \n http://wcm.cycu.org:88/github/cad2024/content/CAD.html \xa0 \n https://github.com/mdecycu/pymadcad \xa0', 'tags': '', 'url': 'Topics.html'}, {'title': 'Network', 'text': '這裡所指的 Network 是 Computer Network，電腦網路可說是目前電腦輔助設計流程的基礎設施，許多輔助設計的軟體透過電腦網路執行認證、協同設計或及時擷取資源。因此進行電腦輔助設計流程之前，必須對所依附使用的電腦網路系統與架構有所了解。 \n IPv6 網路位址分配: \n network_setup.7z \n 2b 分配名單:\xa0 cad_2b_ipv6_address.txt \n Computer Network : \n A \xa0 computer network \xa0 is a collection of communicating \xa0 computers \xa0 and other devices, such as printers and smart phones. In order to communicate, the computers and devices must be connected by wired media like copper cables, \xa0 optical fibers , or by \xa0 wireless communication . The devices may be connected in a variety of \xa0 network topologies . In order to communicate over the network, computers use agreed-on rules, called \xa0 communication protocols , over whatever medium is used. \n The computer network can include \xa0 personal computers , \xa0 servers , \xa0 networking hardware , or other specialized or general-purpose \xa0 hosts . They are identified by \xa0 network addresses \xa0 and may have \xa0 hostnames . Hostnames serve as memorable labels for the nodes and are rarely changed after initial assignment. Network addresses serve for locating and identifying the nodes by communication protocols such as the \xa0 Internet Protocol .', 'tags': '', 'url': 'Network.html'}, {'title': 'ICMP', 'text': 'Allow ping ICMPv4 powershell: \n # Allow inbound ICMPv4 Echo Request (ping)\nNew-NetFirewallRule -Name "Allow ICMPv4-In" -DisplayName "Allow ICMPv4-In" -Protocol ICMPv4 -IcmpType 8 -Direction Inbound -Action Allow \n ICMPv6: \n # Allow inbound ICMPv6 Echo Request (ping)\nNew-NetFirewallRule -Name "Allow ICMPv6-In" -DisplayName "Allow ICMPv6-In" -Protocol ICMPv6 -IcmpType 128 -Direction Inbound -Action Allow \n 允許 ICMP/ICMPv6 的安全性考量 ICMP（包括 ICMPv6）不只是用於 ping，它對許多網路功能來說都是必要的，尤其是在 IPv6 環境下。不過，開放 ICMP/ICMPv6 仍然會帶來一些安全性疑慮： 對於 IPv4（ICMP）： - 攻擊者可以利用 ICMP 進行： \xa0 \xa0 - 偵查：發現存活主機（ping 掃描）。 \xa0 \xa0 - 淹水攻擊：ICMP flood（阻斷服務攻擊）。 \xa0 \xa0 - 網路映射：例如透過 traceroute 等工具。 - 緩解方式：通常會限制 ICMP 類型（如僅允許 Echo Request/Reply），或限制來源 IP，或進行流量速率限制。 對於 IPv6（ICMPv6）： - ICMPv6 對於 IPv6 的運作至關重要！ \xa0 \xa0 - 它支援鄰居探索、路徑 MTU 探查，以及位址自動設定。 \xa0 \xa0 - 若封鎖 ICMPv6，可能會導致 IPv6 無法正常運作，因為路由器與主機都仰賴 ICMPv6 完成這些基本功能。 - 安全性疑慮： \xa0 \xa0 - 偵查：攻擊者仍可發現 IPv6 主機與網段。 \xa0 \xa0 - 潛在濫用：例如 ICMPv6 flood，或偽造鄰居請求（Neighbor Solicitation spoofing）。 - 緩解方式： \xa0 \xa0 - 不要完全封鎖 ICMPv6，而是只允許必要的訊息類型（如 128/129 為 Echo、133-136 為鄰居探索等）。 \xa0 \xa0 - 考慮使用流量速率限制與監控。 \xa0 \xa0 - 檢查防火牆的預設規則——Windows 及現代防火牆通常對 ICMPv6 已有安全的預設值。 \n', 'tags': '', 'url': 'ICMP.html'}, {'title': 'IPv6', 'text': 'IPv6 網路協定是用來解決 IPv4 網路不敷使用的問題而產生。但是目前許多伺服器尚未全面支援 IPv6 網路協定，其原因很多，其中包括使用者欠缺對於 IPv6 網路協定的認識，或者因為伺服器上的用戶程式並未做好支援 IPv6 的準備。無論如何當決定在電腦輔助設計流程使用 IPv6 網路協定後，必須設法因應各種問題，讓採純 IPv6 網路協定設計的環境能夠連線至各個伺服器。 \n IPv6 :\xa0 \n Internet Protocol version 6 \xa0 ( IPv6 ) is the most recent version of the \xa0 Internet Protocol \xa0 (IP), the \xa0 communications protocol \xa0 that provides an identification and location system for computers on networks and routes traffic across the \xa0 Internet . IPv6 was developed by the \xa0 Internet Engineering Task Force \xa0 (IETF) to deal with the long-anticipated problem of \xa0 IPv4 address exhaustion , and was intended to replace \xa0 IPv4 . \xa0 In December 1998, IPv6 became a Draft Standard for the IETF, \xa0 which subsequently ratified it as an \xa0 Internet Standard \xa0 on 14 July 2017. \n', 'tags': '', 'url': 'IPv6.html'}, {'title': 'DNS', 'text': 'DNS 指的是  Domain Name System : \n The\xa0 Domain Name System \xa0 ( DNS ) is a hierarchical and distributed \xa0 name service \xa0 that provides a naming system for \xa0 computers , services, and other resources on the Internet or other \xa0 Internet Protocol \xa0 (IP) networks. It associates various information with \xa0 domain names \xa0 ( identification \xa0 strings ) assigned to each of the associated entities. Most prominently, it translates readily memorized domain names to the numerical \xa0 IP addresses \xa0 needed for locating and identifying computer services and devices with the underlying \xa0 network protocols . [ 1 ] \xa0 The Domain Name System has been an essential component of the functionality of the Internet since 1985. \n', 'tags': '', 'url': 'DNS.html'}, {'title': 'Proxy', 'text': 'https://www.squid-cache.org/ \xa0 \n /etc/squid/squid.con 檔案設定: \n acl cad_lab src 140.130.XX.0/24\nacl cad_lab src 2001:288:6004:XX::/64\n \nacl SSL_ports port 5443\nacl SSL_ports port 8843\n\nacl SSL_ports port 443\nacl Safe_ports port 80 # http\nacl Safe_ports port 88\nacl Safe_ports port 23020\nacl Safe_ports port 1234\nacl Safe_ports port 1235\n \n#acl Safe_ports port 21 # ftp\nacl SSL_ports port 8443\nacl Safe_ports port 8443\n \nacl SSL_ports port 9443\nacl Safe_ports port 9443\n \nacl SSL_ports port 22\nacl Safe_ports port 22\nacl todomainorg dstdomain .domain.org\n\n# add password to access\nauth_param basic program /usr/lib/squid/basic_ncsa_auth /etc/squid/password\nauth_param basic realm proxy\n \nacl Safe_ports port 443 # https\nacl Safe_ports port 1025-65535 # unregistered ports\nacl Safe_ports port 280 # http-mgmt\nacl Safe_ports port 488 # gss-http\nacl Safe_ports port 591 # filemaker\nacl Safe_ports port 777 # multiling http\nacl CONNECT method CONNECT\n\nhttp_access allow cad_lab\n# setup acl for authentication\nacl squid_user proxy_auth REQUIRED\n \nhttp_access allow todomainorg\n\n# Deny requests to certain unsafe ports\nhttp_access deny !Safe_ports\n \n# Deny CONNECT to other than secure SSL ports\nhttp_access deny CONNECT !SSL_ports\n \n# all connection need authentication\nhttp_access allow squid_user\n#http_access deny all\n\n#http_access allow cad_lab\n#http_access deny all\n\n# Only allow cachemgr access from localhost\nhttp_access allow localhost manager\nhttp_access deny manager\n \n#http_access allow localnet\nhttp_access allow localhost\n \n# And finally deny all other access to this proxy\nhttp_access deny all\n \n# Squid normally listens to port 3128\nhttp_port 3128\n \n#cache_dir ufs /var/spool/squid 100 16 256\nicp_port 3130\nicp_access allow all\n \ncache_dir ufs /var/spool/squid 2000 16 256\n#cache_peer 140.130.XX.7 sibling 3128 3130\ncache_peer 2001:288:6004:XX::4 parent 3128 3130 default\ncache_peer 2001:288:6004:XX::42 sibling 3128 3130\ncache_peer 2001:288:6004:XX::69 sibling 3128 3130\ncache_peer 2001:288:6004:XX::53 sibling 3128 3130\ncache_peer 2001:288:6004:XX::3  sibling 3128 3130\n\n \n#\n# Add any of your own refresh_pattern entries above these.\n#\nrefresh_pattern ^ftp: 1440 20% 10080\nrefresh_pattern ^gopher: 1440 0% 1440\nrefresh_pattern -i (/cgi-bin/|\\?) 0 0% 0\nrefresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880\nrefresh_pattern . 0 20% 4320\n \n Ubuntu 系統更新指令: \n ssh  account@server \n sudo apt update \n sudo atp upgrade \n sudo apt autoremove \n \n', 'tags': '', 'url': 'Proxy.html'}, {'title': 'Web', 'text': 'wcm:88 nginx.conf 設定檔案: \n #user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n    #                  \'$status $body_bytes_sent "$http_referer" \'\n    #                  \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       [::]:80 default ipv6only=on;\n        server_name  wcm.domain.org;\n        return       301 https://$server_name$request_uri;\n        \n        allow 140.130.XX.0/24;\n        allow 2001:288:6004:XX::0/32;\n        deny all;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        #location / {\n            #root   html;\n            #index  index.html index.htm;\n        #}\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        #error_page   500 502 503 504  /50x.html;\n        #location = /50x.html {\n            #root   html;\n        #}\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache\'s document root\n        # concurs with nginx\'s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n    \n       server {\n        listen       [::]:88 ipv6only=off;\n        listen       88;\n        \n        allow 140.130.XX.0/24;\n        allow 2001:288:6004:XX::0/32;\n        deny all;\n        \n        location / {\n            root C:/server/nginx-1.20.2/spring2022;\n            charset utf-8;\n        }\n        \n        location /i {\n            alias i:/;\n        }\n        \n        autoindex on;\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n \n 229 nginx.conf 設定檔案: \n #user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n    #                  \'$status $body_bytes_sent "$http_referer" \'\n    #                  \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        # allow IPv4 and IPv6 to downloa files with specified URL\n        listen        80;\n        listen [::]:80;\n        server_name  229.domain.org;\n        root C:\\\\Users\\\\server\\\\files\\\\2024_spring;\n        \n        auth_basic "Restricted Content";\n        auth_basic_user_file C:\\\\Users\\\\server\\\\files\\\\nginx-1.24.0\\\\conf\\\\.htpasswd;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            # if set the root to html, only the index file type can be accessed\n            #root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache\'s document root\n        # concurs with nginx\'s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n \n \n', 'tags': '', 'url': 'Web.html'}, {'title': 'Codespaces', 'text': 'https://github.com/codespaces \xa0 \n', 'tags': '', 'url': 'Codespaces.html'}, {'title': 'Software', 'text': "這裡的 Software 指的是電腦軟體，執行電腦輔助設計時會接觸電腦操作系統、電腦輔助設計套件以及全球資訊網相關的各種應用軟體。 \n Software : \n The history of software is closely tied to the development of digital computers in the mid-20th century. Early programs were written in the \xa0 machine language \xa0 specific to the hardware. The introduction of \xa0 high-level programming languages \xa0 in 1958 allowed for more human-readable instructions, making \xa0 software development \xa0 easier and more portable across different \xa0 computer architectures . Software in a programming language is run through a \xa0 compiler \xa0 or \xa0 interpreter \xa0 to \xa0 execute \xa0 on the architecture's hardware. Over time, software has become complex, owing to developments in \xa0 networking , \xa0 operating systems , and \xa0 databases . \n Software can generally be categorized into two main types: \n \n operating systems , which manage hardware resources and provide services for applications \n application software , which performs specific tasks for users \n \n The rise of \xa0 cloud computing \xa0 has introduced the new software delivery model \xa0 Software as a Service \xa0 (SaaS). In SaaS, applications are hosted by a \xa0 provider \xa0 and \xa0 accessed \xa0 over the \xa0 Internet . \n The process of developing software involves several stages. The stages include \xa0 software design , \xa0 programming , \xa0 testing , \xa0 release , and \xa0 maintenance . \xa0 Software quality assurance \xa0 and \xa0 security \xa0 are critical aspects of software development, as \xa0 bugs \xa0 and \xa0 security vulnerabilities \xa0 can lead to system failures and security breaches. Additionally, legal issues such as software licenses and intellectual property rights play a significant role in the distribution of software products. \n \n", 'tags': '', 'url': 'Software.html'}, {'title': 'Git', 'text': 'Git and Github \n 電腦輔助機械設計流程: \n 每六位學員一組，請自選套件協同完成平面 四連桿機構 的零組件設計繪圖。完成後請詳細說明設計與繪圖過程。 \n', 'tags': '', 'url': 'Git.html'}, {'title': 'CMSiMDE', 'text': '可攜 Python 程式環境，使用 miniconda3: \n Miniconda is a free, miniature installation of Anaconda Distribution that includes only conda, Python, the packages they both depend on, and a small number of other useful packages. If you need more packages, use the conda install command to install from thousands of packages available by default in Anaconda’s public repo, or from other channels, like conda-forge or bioconda. \n 授權方式\xa0 \xa0 BSD 3-Clause License（自由軟體） 是否開源\xa0 \xa0 是（可以查閱與修改原始碼） 是否免費\xa0 \xa0 是（個人與商業皆免費使用） 用途限制\xa0 \xa0 無限制，可用於學術、商業、開發、產品部署等 提供單位\xa0 \xa0 Anaconda, Inc. \n 官方網站:\xa0 https://www.anaconda.com/download/success \xa0 \n miniconda3.7z \n start_miniconda3_bat.txt \n 啟動 miniconda3 虛擬環境後，在命令列中執行下列批次檔案，可以導入 NX2312 與 Webots 所需的 Python 模組目錄設定。 \n add_nx_webots_pythonpath_bat.txt \n check python path:\xa0python -c "import sys; print(sys.executable)" \n 啟動後 Python 環境位於 base，利用下列指令建立 cmsimde 虛擬環境: \n conda create -p ./envs/cmsimde python=3.13 \n conda activate y:\\envs\\cmsimde \n conda install -c conda-forge flask flask_cors bs4 lxml pelican markdown gevent \n 之後就可以 cd tmp/your_hw_repository 後，以 cms 啟動網頁編輯。 \n', 'tags': '', 'url': 'CMSiMDE.html'}, {'title': 'Flask', 'text': '', 'tags': '', 'url': 'Flask.html'}, {'title': 'Solvespace', 'text': 'Solvespace:  https://solvespace.com \n Jansen_whitworth_mechanism.7z \n https://github.com/mdecycu/WalkerBot-MakerKit \xa0 \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Compile', 'text': '', 'tags': '', 'url': 'Compile.html'}, {'title': 'NX', 'text': "目前全球業界對 Siemens NX X(不是 NX，而是 NX 雲端版)接受度如何? 總數大約多少? 優勢與弱點何在? 競爭對手產品有哪些? \n 目前台灣業界對 Siemens NX X(不是 NX，而是 NX 雲端版)接受度如何?\xa0總數大約多少? 優勢與弱點何在? 競爭對手產品有哪些? \n \n Siemens NX2312 與 NX2506 在 CAD 零組件繪圖部分的功能，最大的差異為何? 為何會有這些改變? \n \n \n Siemens NX2506 的變更內容: \n 零件繪圖: \n 現代化 UI：鉛筆游標、動態手柄、顏色編碼 snapping（紅：無 snapping；黃：點對曲線；綠：重合）。 \n 支持多輸入（滑鼠、觸控筆、觸控螢幕），MB1 按壓拖曳創建線/弧。 \n 手勢控制：搖晃斷開切線、MB2 方向鎖定、塗鴉手勢修剪/延伸。 \n 新工具：鎖定長度/角度/半徑參數、鏈接曲線創建輪廓、從中點創建線、正方形從中心、Tangent Sliding（切線滑動）。 \n 生成參考幾何與無限線/線段選項。 \n 建模與組立: \n Axial Pattern 新增：結合圓柱/線性圖案，支持錐面與軸向交錯（Stagger），整合至 Pattern Feature/Geometry/Face/Reference Pattern。 \n Interpart Navigator with Diagram：視覺化組裝關係（黑線：結構；綠曲線：關係），Pack Nodes 隱藏無連結節點。 \n 增強 Boolean（Unite/Subtract/Intersect）：支持空特徵組、非交集處理，排除薄片體。 \n Mirror Body：刪除原體選項、智能收集器自動偵測。 \n Offset Surface：自動偵測自交點並警示，Split Output along Boundary Curves 維持表面連續性。 \n UI: \n 直觀 UI 與 API 支援，保留舊互動但新增現代方式。 \n 更好錯誤處理（如自交點警示）。 \n 這些 NX2506 改變主要源自 Siemens 對客戶反饋的回應，以及產業趨勢需求： \n 提升生產力與靈活性 \n 在 NX 2312 版本之後，Siemens 收集了大量用戶反饋，指出傳統 Sketcher 工具在處理複雜零件繪圖時存在明顯的效率瓶頸，例如需要頻繁切換命令、多次點擊調整 snapping（吸附）點，以及手動處理曲線連續性，導致設計流程緩慢且容易中斷創意流程。 \n 這些問題在高密度零件建模中尤為突出，例如涉及多層輪廓或精確尺寸約束的零組件設計。為了應對這些痛點，NX 2506 對 Sketcher 進行了全面重構，引入了更先進的手勢控制、拖曳式互動以及智能 snapping 機制。具體來說，廢除了舊版的獨立 Profile 工具，取而代之以整合的線條和弧線創建模式，使用者可以透過按壓拖曳直接生成輪廓，同時支援動態手柄調整和顏色編碼 snapping（例如紅色表示無吸附、黃色為點對曲線、綠色為完全重合），這大大減少了對話框彈出和步驟切換。Siemens 官方將這些改進形容為「遊戲規則改變者」（game-changer），因為它們能將繪圖時間縮短 20-30%，讓設計師更專注於創意迭代而非繁瑣操作。 \n 適應現代硬體與工作環境 \n NX 2506 的更新特別強調對現代硬體的適應性，主要是為了回應遠距工作、行動設計和混合辦公環境的興起。在 NX 2312 中，互動主要依賴傳統滑鼠和鍵盤，缺乏對觸控設備的優化，這在平板電腦或遠端協作時成為限制。NX 2506 引入了多輸入支援，包括觸控筆、觸控螢幕和手勢操作，讓使用者能在平板或混合裝置上流暢進行零件繪圖，例如透過觸控拖曳直接創建弧線或調整 snapping 點。這不僅滿足了遠距設計需求（如在家或現場使用平板建模），還降低了對專用工作站的依賴，提升了工作靈活性。 \n 此外，顏色編碼 snapping 和動態 UI（例如實時手柄和視覺反饋）進一步改善了使用者體驗，這些元素提供即時視覺指引，減少了試錯時間並降低學習曲線。新手設計師能更快上手，而資深用戶則受益於更直觀的互動，例如在複雜零組件繪圖中，動態 UI 能自動突出潛在錯誤（如自交點）。這些改進源自 Siemens 對使用者工作環境的調查，旨在讓 NX 成為更包容的工具，支援從桌面到行動的無縫轉換，從而適應現代工程師的多樣化工作模式。 \n 產業需求驅動 \n 汽車和航太產業對高精度組件建模的需求是 NX 2506 更新的一大驅動力，這些領域常涉及複雜的零組件組裝，如引擎部件或飛機結構，需要精確的關係管理和表面連續性。在 NX 2312 中，組裝分析工具較為基礎，容易在下游模擬階段暴露錯誤。NX 2506 引入了增強的 Interpart Navigator，配以圖表式視覺化（Diagram 模式），使用黑線表示結構關係、綠曲線顯示約束連結，並支援 Pack Nodes 隱藏無關節點，這大大提升了組裝效率，讓工程師能快速診斷和解決零組件間的潛在衝突，減少了下游錯誤如碰撞或不匹配。 \n 同時，Boolean 操作（Unite/Subtract/Intersect）和 Mirror Body 功能的增強針對高品質表面需求，例如支援排除薄片體、非交集處理，以及智能收集器自動偵測和刪除原體選項，確保表面連續性（G1/G2 連續）。這直接支援下游模擬（如有限元素分析）和 CAM 製造，特別在汽車（精密齒輪組裝）和航太（輕量結構）中，避免了重工並提升產品品質。這些改變源自產業反饋，Siemens 透過客戶調查和合作（如與製造夥伴）確認了這些痛點，目的是讓 NX 更好地服務高精度應用，維持競爭優勢。 \n 技術進展 \n Siemens 一直強調 NX 作為統一平台的定位，將 CAD、CAM 和 CAE 整合成一體化生態，這是 NX 2506 更新背後的核心邏輯。相較 NX 2312 的穩定基礎，NX 2506 引入了與 AI 工具的深度整合，雖然 AI 並非核心 CAD 功能，但它影響整體工作流程，例如透過 AI 驅動的自動特徵辨識、優化建議和數字孿生模擬，輔助零件繪圖和零組件建模。具體來說，NX 2506 與 Teamcenter 2506 聯動，提供 AI-powered 功能如生成式設計輔助和實時決策支援，這讓 CAD 流程更智能，例如在 Sketcher 中 AI 可建議 snapping 優化，或在 Axial Pattern 中自動調整參數以符合製造約束。 \n 這些更新旨在提升 NX 的競爭力，面對如 SolidWorks 或其他 CAD 軟體的挑戰，Siemens 透過 AI 和雲端整合（如 API 連接和雲端製造服務）讓 NX 更具前瞻性，支援工業級 AI 應用如 CNC 優化和部件生產效率提升。官方釋出註記強調這些進展是為了增加效率和創新，基於技術趨勢如 AI 與數字孿生的融合，讓 NX 2506 不僅是工具升級，更是平台演進。 \n Siemens NX 與 NX X 的並存情況 \n 根據 Siemens 官方訊息，NX 與 NX X 將一直並存，並非互斥或取代關係。NX 是傳統的 on-premise（本地安裝）版本，提供完整的 CAD/CAM/CAE 功能，適合需要高度自訂化與本地控制的企業；NX X 則是基於雲端的 SaaS（Software as a Service）版本，強調雲端授權、即時更新與協作，針對現代混合工作環境設計。兩者建構於相同的 NX 架構與資料模型之上，確保完全互通性（interoperability），可無縫共享資料與功能，支援從設計到製造的全流程整合。這一並存策略是 Siemens Xcelerator 平台的核心部分，讓用戶根據需求選擇部署方式，而非強制遷移。 \n 關鍵官方依據與細節 \n 並存與互通性確認：Siemens 明確表示「All Siemens Xcelerator software, including all NX products, are interoperable and can share data seamlessly」（所有 Siemens Xcelerator 軟體，包括所有 NX 產品，皆可互通並無縫共享資料）。這涵蓋 NX（on-premise）與 NX X（雲端），允許用戶在兩者間自由切換，而無需資料轉換或相容性問題。 例如，NX X 的桌面安裝版使用雲端授權，但可與傳統 NX 整合，支援混合環境。 \n 部署選擇的靈活性：官方文件指出，「Whether you want to manage your own IT environment or leverage software as a service, Siemens' NX CAD has licensing options for how you work. You'll have the same core features and release/update cadence no matter how you choose to run NX CAD.」這意味無論選擇 NX 或 NX X，都享有相同核心功能與更新節奏（每 6 個月新增模組），確保並存不會導致功能落差。 NX X 提供四個階層（Essentials、Standard、Advanced、Premium），但不取代 NX，而是作為補充，讓小型團隊或遠距協作更便捷。 \n 未來更新與持續支援：在 2025 年夏季更新中，Siemens 同時發布 NX 與 NX X 的新功能，如 AI Copilot（設計輔助）、沉浸式工程（mixed reality 協作）與流體模擬，證明兩者將同步演進。 官方強調 NX X 的雲端管理（自動更新）與 NX 的本地穩定性將長期並行，無終止傳統版本的計畫。這回應產業趨勢，讓企業逐步過渡至雲端，而非強迫。 \n 為何會並存？ \n Siemens 的策略是提供「選擇權」（it's your choice），回應不同用戶需求：大型企業偏好 NX 的自訂化與安全性；新創或分散團隊則青睞 NX X 的低門檻與協作。 這種並存不僅維持市場領導地位（NX 在 CAD 評比中高分），還加速創新，如透過雲端整合 AI 與數字孿生。 若需遷移，Siemens 提供工具與支援，確保平滑轉換。", 'tags': '', 'url': 'NX.html'}, {'title': 'NX2312', 'text': '這裡將使用電腦輔助設計室所安裝的 NX2312 套件. \n Siemens NX:  https://plm.sw.siemens.com/en-US/nx/ \n NX2312 Documentation \n NXOpen:  https://github.com/mdecycu/nxopen \n Setup NXOpen Python Intellisense \n 在自己的電腦上，以可攜方式執行 NX2312: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n cad_data.7z  (包括 NX2312、Blender4.2 與 Webots2023b，4.2GB) \n 解開壓縮檔，將 nx、Webots_2023b 與 Blender 4.2 等目錄放入可攜系統的 data 目錄中。 \n 在命令列執行 webotsw 可啟動 Webots，設定 NX 使用授權後，執行 ugraf -nx 可啟動 NX2312。 \n Webots2023b 啟動時需要\xa0openssl_lh_set_thunks 函式，因為這是特別的 OpenSSL 介接，其目的可能是透過此函式與 OpenSSL 整合記憶體分配、除錯、或 OpenSSL 引擎擴充。 \n 目前已知 miniconda 中必須透過 conda install openssl=3.0.16 安裝舊版後的 openssl-3-x64.dll 中才會包含openssl_lh_set_thunks 函式。 \n Microsoft Visual C++ 可轉散發套件 \xa0( VC_redist.x64.exe ) \n 在電腦輔助設計室中，利用可攜套件設定，執行安裝於 C: 中的 NX2312: \n 修改\xa0start_miniconda3.bat，將可攜套件 NX 路徑換成 C: 中安裝 NX2312 所在路徑後，將批次檔案存為 start_cadlab_nx.bat \n NX2312 NXOpen Python 動態連結程式庫版本: Python 3.10.9 \n 在可攜程式環境中利用 miniconda3 建立 nxopen 虛擬環境 (注意: 必須使用反斜線分隔目錄名稱): \n conda create -p y:\\envs\\nxopen python=3.10  指定建立 nxopen Python 環境，並使用 3.10 版。 \n conda activate y:\\envs\\nxopen  將 Python 環境切換到 nxopen env。 \n where python  查詢目前 env 所使用的 Python 所在目錄位置。 \n conda clean --all  刪除安裝 env 時所下載的安裝套件以及暫存檔案。 \n 進入 nxopen 虛擬環境後，在命令列執行下列 PYTHONPATH 設定，可以使用 Python\xa0 \n add_nx_webots_pythonpath_bat.txt \n 若要在 SciTE 編輯器中指令使用 nxopen env 中的 Python，可以先在命令列中以 conda activate nxopen 後，接著以 where python 查詢所使用 python.exe 所在目錄後，利用處於同樣目錄的 pythonw.exe 設定 python.properties: \n if PLAT_WIN \xa0 \xa0 python.command=y:\\envs\\nxopen\\python.exe \n 完成 python.properties 設定修改後，在命令列中利用\xa0start /MIN y:\\wscite\\SciTE.exe\xa0 開啟編輯器後，以下列程式查詢所使用的 conda env，以及所使用的 Python 版本: \n import sys\nimport os\n\nconda_env = os.environ.get("CONDA_DEFAULT_ENV")\nprint(f"Conda env：{conda_env}")\nprint(f"Python version: {sys.version}") \n', 'tags': '', 'url': 'NX2312.html'}, {'title': 'License', 'text': '在電腦輔助設計過程使用電腦套件時，必須明確了解該套件的使用授權。本課程所使用的  CMSiME  為  GNU Affero General Public License v3.0 ，而 Siemens NX 除了一般教育單位購買的授權外，也提供 學生使用授權 。 \n Siemens NX 使用了很多開源軟體，其使用授權:\xa0 https://download.industrysoftware.automation.siemens.com/open-source/ \xa0 \n 教育單位使用 Siemens NX 的使用授權:\xa0 NX2312 版權宣告 \n License Server (認證伺服器) \n https://support.sdasoftware.com/portal/en/kb/articles/siemens-license-server-installation-and-setup \xa0 \n NX2212 之後的認證伺服器變更:\xa0 https://support.sw.siemens.com/en-US/okba/PL8687318/NX-2212-licensing-changes-Mandatory-use-of-Siemens-License-Server/index.html \xa0 \n 一旦全面 SaaS 化之後的 Siemens Nx，客戶端的使用認證將不再依賴近端的認證伺服器。 \n SaaS 之後的 Siemens NX X:\xa0 https://resources.sw.siemens.com/en-US/video-introducing-nx-x-nx-as-a-saas-solution/ \xa0 \n', 'tags': '', 'url': 'License.html'}, {'title': 'NX2506', 'text': 'NX2506 Online Help \n NX2506 需要: \n https://dotnet.microsoft.com/en-us/download/dotnet/8.0 \xa0 \n Microsoft Visual C++ Redistributable  (2015 - 2022) \n NX2506 Python 採用 3.12.9 (NX2412 則採用 Python 3.11.9) \n NX2506 完整安裝容量約 38GB (NX2412 完整安裝容量則約 37GB) \n NX2506 可攜啟動與 NXOpen 設定: \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_ipv6\nset HomeDrive=%Disk%:\\home_ipv6\nset Home=%Disk%:\\home_ipv6\nset USERPROFILE=%Disk%:\\home_ipv6\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\envs\\nx2506\\DLLs;%Disk%:\\envs\\nx2506\\Lib;%Disk%:\\envs\\nx2506\\Lib\\site-packages;%Disk%:\\NX2506\\NXBIN\\python;%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin;%Disk%:\\Webots_2023b\\lib\\controller\\python;\nset PYTHONHOME=%Disk%:\\envs\\nx2506\nREM for Webots\nset PYTHON_PATH=%Disk%:\\envs\\nx2506\nset WEBOTS_HOME=%Disk%:\\Webots_2023b\n\nREM for putty\nset GIT_SSH=%Disk%:\\PuTTY\\plink.exe\n\nREM 設定跟 Python 有關的命令搜尋路徑\nset path_python=%Disk%:\\envs\\nx2506;%Disk%:\\envs\\nx2506\\Scripts;\nREM 設定跟Git 有關的命令搜尋路徑\nset path_git=%Disk%:\\portablegit\\bin;\n\nREM for execute scite directly\nset path_scite=%Disk%:\\wscite\\;\n\nREM for webots\nset  path_webots=%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin;%Disk%:\\Webots_2023b\\msys64\\usr\\bin\n\nREM for blender\nset path_blender=%Disk%:\\Blender_4.2;\n\npath=%Disk%:;%path_python%;%path_git%%path_scite%;%path_webots%;%path_blender%;%path%;\n\nREM for NX2312, must after path setup \nset UGII_ENV_FILE=%Disk%:\\NX2506\\UGII\\ugii_env_ug.dat\nset SPLM_LICENSE_SERVER=29000@your_License_Server\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%Disk%:\\NX2506\\\nset UGII_TMP_DIR=%Disk%:\\tmp\\nx2506\nset UGII_LIB_PATH=%Disk%:\\NX2506\\NXBIN\\python\nset ugii=%Disk%:\\NX2506\\ugii;%Disk%:\\NX2506\\nxbin;\npath = %ugii%;%path%\nREM Xcopy %Disk%:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y\n\nREM start ugraf -nx\n\nREM 切換到 nx2506\ncall "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\nx2506\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite\\SciTE.exe\n\nREM start webotsw.exe\n\nExit', 'tags': '', 'url': 'NX2506.html'}, {'title': 'Onshape', 'text': 'OnShape:  https://www.onshape.com/en/ \n 教師 Onshape 帳號: course At mde dot tw \n https://github.com/PChild/onshape-to-webots \xa0 \n https://github.com/mdecycu/onshape-to-robot \xa0', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Webots', 'text': 'https://cyberbotics.com/ \n https://www.slideshare.net/slideshow/tpwebots7mai2021pdf/259157378 \xa0 \n https://introduction-to-autonomous-robots.github.io/lab-manipulation-introduction.html \xa0 \n https://www.instructables.com/Vacuum-Cleaner-Robot-in-Webots/ \xa0 \n https://www.eecs.ucf.edu/cssd/fall13/ucfsr/files/FinalDoc.pdf \xa0 \n 在自己的電腦上，以可攜方式執行 Webots: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n cad_data.7z  (包括 NX2312、Blender4.2 與 Webots2023b，4.2GB) \n 解開壓縮檔，將 nx、Webots_2023b 與 Blender 4.2 等目錄放入可攜系統的 data 目錄中。 \n 在命令列執行 webotsw 可啟動 Webots，設定 NX 使用授權後，執行 ugraf --nx 可啟動 NX2312。 \n Webots2023b 啟動時需要\xa0openssl_lh_set_thunks 函式，因為這是特別的 OpenSSL 介接，其目的可能是透過此函式與 OpenSSL 整合記憶體分配、除錯、或 OpenSSL 引擎擴充。 \n 目前已知 miniconda 中必須透過 conda install openssl=3.0.16 安裝舊版後的 openssl-3-x64.dll 中才會包含openssl_lh_set_thunks 函式。 \n Microsoft Visual C++ 可轉散發套件 \xa0( VC_redist.x64.exe ) \n 由於 NX2312 中的 NXOpen Python 必須使用 Python 3.10 版的解譯器，才能與位於\xa0y:\\NX\\NXBIN\\python 目錄中的動態連結程式結合。 \n 而 Webots_2023b 若要採 extern 外部控制器設定，則必須在切換 env 後，額外設定 PYTHONPATH 至 y:\\Webots_2023b\\msys64\\mingw64\\bin 以及 y:\\Webots_2023b\\lib\\controller\\python，才可連結其內建的 Python 控制器模組，只是 Webots 的控制器模組採 Python 程式碼編寫，因此可以在 Python 3.10 以上的版本中執行，因此只要 PYTHONPATH 納入 Webots 控制器模組後，可以選擇 base、cmsimde 或 nxopen 等 env 中的 Python 進行配置。 \n 若 Webots Python 控制器需要額外安裝 numpy、scipy、opencv-python、matplotlib 或其他模組，也可以獨立配置一個 webots env 提供使用: \n conda create -p y:\\envs\\webots python=3.13 \n conda activate y:\\envs\\webots \n where python \n conda clean --all \n 並將 Webots 下拉式功能表中的 Tools - Preferences - Python command 欄位指向 webots env 所對應的 python，或者將控制器設為 extern，然後由 SciTE 選擇使用 Webots 合用的 Python 版本與模組套件。 \n Webots 啟動: \n webotsw --mode=pause (啟動時不會自動執行 controller) \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Fourbar', 'text': 'fourbar_box.7z \n fourbar_slvs.7z \n \n Edit fourbar.smm \n', 'tags': '', 'url': 'Fourbar.html'}, {'title': 'TimeStep', 'text': '在 Webots 模擬器中， 模擬器的時間步長 與 世界的時間步長 是模擬運行的兩個重要概念，分別表示模擬器和模擬世界在離散物理計算中的時間間隔。以下是詳細說明： \n 1.  模擬器的時間步長（Simulator  Time  Step） \n \n 定義 ：模擬器內部用於計算物理模擬的時間間隔。它決定了模擬器每次更新物理場景時所模擬的時間量。 \n 作用 ： \n \n 控制系統的精度與性能。 \n 計算物理行為（如碰撞、運動等）的關鍵參數。 \n \n \n 設置方式 ：模擬器的時間步長通常由模擬控制器中的代碼明確設置。例如，在 Python 控制器中，您可以使用 robot.step(timestep) 來進行控制。 \n 特性 ： \n \n 越小 ：模擬精度越高，但計算負擔增加，模擬速度可能變慢。 \n 越大 ：模擬速度提高，但精度降低，可能導致模擬不穩定。 \n \n \n \n 2.  世界的時間步長（World  Time  Step） \n \n 定義 ：模擬世界中用於更新場景的固定時間間隔，主要由 Webots 的場景樹（Scene  Tree）中的  WorldInfo  >  basicTimeStep   參數定義。 \n 作用 ： \n \n 控制整個模擬場景中物體更新的頻率。 \n 決定模擬器每次計算後，虛擬時間向前推進的時間量。 \n \n \n 設置方式 ：可以在場景樹的  WorldInfo  節點中修改  basicTimeStep  參數值。 \n 特性 ： \n \n 越小 ：模擬的物理場景更新更加頻繁，但所需計算資源更多。 \n 越大 ：模擬場景更新較少，可能導致物理行為的細節丟失。 \n \n \n \n 3.  兩者的關係 \n \n 模擬器的時間步長 應該 小於或等於 世界的時間步長。 \n \n 原因是：模擬器需要在每個世界時間步長內完成多次計算，以確保物理模擬的準確性。 \n 如果模擬器的時間步長大於世界的時間步長，可能導致模擬不穩定，甚至出現錯誤。 \n \n \n 設置建議 ： \n \n 一般情況下，模擬器的時間步長可以設置為世界時間步長的一部分（如1/10）。 \n 測試不同的時間步長，根據模擬精度與性能需求進行調整。 \n \n \n \n 4.  實際應用場景 \n \n 模擬器的時間步長 ： \n \n 用於控制機器人的控制器代碼，例如逐步執行機器人的操作或模擬傳感器的更新。 \n \n \n 世界的時間步長 ： \n \n 用於控制整個模擬場景的更新頻率，例如物體的運動、碰撞檢測等。 \n \n \n \n \n 簡單對比 \n \n \n \n 項目 \n 模擬器的時間步長 \n 世界的時間步長 \n \n \n \n \n 定義 \n 模擬器內部計算的時間間隔 \n 模擬世界中場景更新的時間間隔 \n \n \n 設置位置 \n 控制器代碼中 \n 場景樹的 WorldInfo 節點 \n \n \n 影響 \n 控制模擬計算的精度與性能 \n 控制整個場景的更新頻率 \n \n \n 大小關係 \n 必須小於或等於世界時間步長 \n 可設置為模擬所需的任意值 \n \n \n \n 透過合理設置這兩個參數，可以在模擬的精度與性能之間達到平衡。 \n', 'tags': '', 'url': 'TimeStep.html'}, {'title': 'Clouds', 'text': 'https://cyberbotics.com/doc/guide/web-streaming \n Webots 透過 webotsw --stream 所啟動的串流伺服器, 可以將串流內容導向全球資訊網伺服器, 利用下列超文件透過 Websocket 檢視 Webots 串流場景. \n index4.html \n <!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <title>Streaming viewer</title>\n    <link rel="icon" type="image/png" href="webots_icon.png">\n    <link type="text/css" rel="stylesheet" href=\'style.css\' />\n    <style>\n      html, body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n      body {\n        width: 100vw;\n        height: 100vh;\n        min-height: 100vh;\n        min-width: 100vw;\n        display: flex;\n        flex-direction: column;\n        background: #222;\n      }\n      header {\n        flex: 0 0 auto;\n        padding: 0;\n        margin: 0;\n        background: #181818;\n        color: #fff;\n        text-align: center;\n      }\n      .title-container {\n        margin: 0;\n        padding: 0.5em 0;\n      }\n      .webots-view-container {\n        flex: 1 1 0;\n        display: flex;\n        align-items: stretch;\n        justify-content: stretch;\n        min-height: 0;\n        min-width: 0;\n      }\n      webots-view {\n        width: 100vw;\n        height: 100vh;\n        flex: 1 1 0;\n        display: block;\n        min-width: 0;\n        min-height: 0;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="webots-view-container">\n      <webots-view></webots-view>\n    </div>\n    <script type="module" src="http://localhost:8000/wwi/WebotsView.js"></script>\n    <script>\n      // Default WebSocket parameters\n      const defaultIp = "ws://localhost:1234";\n      const defaultStreamingMode = "x3d";\n      const defaultBroadcast = false;\n      const mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n      const defaultThumbnail = \'./../wwi/images/loading/default_thumbnail.png\';\n\n      // Optional: load mobile CSS if on mobile device\n      if (mobileDevice) {\n        let head = document.getElementsByTagName(\'head\')[0];\n        let mobileCss = document.createElement(\'link\');\n        mobileCss.setAttribute(\'rel\', \'stylesheet\');\n        mobileCss.setAttribute(\'type\', \'text/css\');\n        mobileCss.setAttribute(\'href\', \'./../wwi/css/wwi_mobile.css\');\n        head.appendChild(mobileCss);\n      }\n\n      // Wait for WebotsView.js to load and custom element to be defined\n      window.addEventListener(\'DOMContentLoaded\', () => {\n        customElements.whenDefined(\'webots-view\').then(() => {\n          const webotsView = document.querySelector(\'webots-view\');\n          webotsView.onready = () => {\n            console.log("Connected to Webots streaming server!");\n          };\n          webotsView.ondisconnect = () => {\n            console.log("Disconnected from Webots streaming server!");\n          };\n          webotsView.connect(defaultIp, defaultStreamingMode, defaultBroadcast, mobileDevice, -1, defaultThumbnail);\n        });\n      });\n    </script>\n  </body>\n</html>\n \n 下列 Python 程式執行時則可動態建立近端伺服器, 並直接利用 Edge 開啟 index4.html 中的 Webots 場景. \n python_www_server.py \n import http.server\nimport socketserver\nimport threading\nimport webbrowser\nimport time\nimport os\nimport sys\nimport subprocess\n\nPORT = 8000\nDIRECTORY = os.path.dirname(os.path.abspath(__file__))\n\nclass Handler(http.server.SimpleHTTPRequestHandler):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, directory=DIRECTORY, **kwargs)\n\ndef open_edge(url):\n    # Try common Edge paths on Windows\n    edge_paths = [\n        r"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",\n        r"C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe"\n    ]\n    for path in edge_paths:\n        if os.path.exists(path):\n            subprocess.Popen([path, url])\n            return True\n    # Fallback: try using webbrowser module (may open in default browser)\n    try:\n        webbrowser.get(\'windows-default\').open(url)\n    except:\n        webbrowser.open(url)\n    return False\n\ndef run_server():\n    with socketserver.TCPServer(("", PORT), Handler) as httpd:\n        print(f"Serving at http://localhost:{PORT}")\n        httpd.serve_forever()\n\nif __name__ == "__main__":\n    # Start server in a thread\n    server_thread = threading.Thread(target=run_server, daemon=True)\n    server_thread.start()\n\n    # Wait a moment for the server to start\n    time.sleep(1)\n\n    # Open Edge to the local index.html\n    url = f"http://localhost:{PORT}/streaming_viewer/index4.html"\n    print(f"Opening {url} in Edge...")\n    open_edge(url)\n\n    # Keep main thread alive to keep server running\n    try:\n        while True:\n            time.sleep(10)\n    except KeyboardInterrupt:\n        print("Shutting down.")\n        sys.exit(0) \n webots_stream.7z \n 在雲端提供多 Webots 場景串流的方法是, 每一個場景採 \n webotsw my_world.wbt --stream --port 8888 \n 在 8888 埠號串流 my_world.wbt 場景, 並在 WWW 伺服器中指定要開啟的 port 就能利用一台雲端主機檢視多個由使用者上傳的場景. 再加上 https 設定, 建立類似\xa0 https://webots.cloud/ \xa0的服務. \n cloud ( https://github.com/cyberbotics/webots-cloud ) 中的 html 如下: \n <!DOCTYPE html>\n<html>\n<head>\n  <meta charset="utf-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">\n  <title id="title">webots.cloud</title>\n  <meta name="description" content="Run Webots simulations in the cloud">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <meta name="og:locale" content="en">\n  <meta name="og:type" content="website">\n  <meta name="og:title" content="webots.cloud">\n  <meta name="og:description" content="The place to share Webots simulations.">\n  <meta name="og:updated_time" content="1587637793">\n  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />\n  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.css">\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css"/>\n  <link rel="stylesheet" href="/css/webots-cloud.css">\n</head>\n<body>\n  <div class="scrollable-body" id="scrollable-body"></div>\n  <script src="/js/webots-cloud.js" type="module"></script>\n</body>\n<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>\n<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.3.0/showdown.min.js"></script>\n<script src="https://cyberbotics.com/showdown/1.3.0/showdown-youtube.min.js"></script>\n<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.0.0/mermaidAPI.min.js"></script>\n<script src="https://cdn.jsdelivr.net/gh/cyberbotics/webots@released/docs/js/showdown-extensions.js"></script>\n</html>\n \n 在 w_dot_mde 設定: \n nginx.conf (主要讓 wss:// 透過 https 反向代理. \n #user  nobody;\nworker_processes  1;\n \n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n \n#pid        logs/nginx.pid;\n \nevents {\n    worker_connections  1024;\n}\n \nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n \n    sendfile        on;\n    keepalive_timeout  65;\n \n    # Redirect HTTP to HTTPS\n    server {\n        listen [2001:288:6004:17::XX]:80;\n        server_name  XX.nfu.edu.tw;\n \n        return 301 https://$host$request_uri;\n    }\n \n    # HTTPS server\n    server {\n        listen [2001:288:6004:17::XX]:443 ssl;\n        server_name XX..nfu.edu.tw;\n \n        ssl_certificate      C:/Certbot/live/w.mde.nfu.edu.tw/fullchain.pem;\n        ssl_certificate_key  C:/Certbot/live/w.mde.nfu.edu.tw/privkey.pem;\n \n        ssl_protocols        TLSv1.2 TLSv1.3;\n        ssl_ciphers          HIGH:!aNULL:!MD5;\n \n        location / {\n            #root   html;\n            root html/webots_resources_web/;\n            index  index.html index.htm;\n        }\n        \n        # Webots streaming server 的 WebSocket 反向代理\n        location /webots_ws/ {\n            proxy_pass http://localhost:1234/;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection "upgrade";\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        location /auto_shoot/ {\n            proxy_pass http://localhost:1235/;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection "upgrade";\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n \n        error_page 404 /404.html;\n        location = /40x.html {\n        }\n \n        error_page 500 502 503 504 /50x.html;\n        location = /50x.html {\n        }\n    }\n} \n 此時的 index.html 設為: \n <!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <title>Streaming viewer</title>\n    <link rel="icon" type="image/png" href="webots_icon.png">\n    <link type="text/css" rel="stylesheet" href=\'style.css\' />\n    <style>\n      html, body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n      body {\n        width: 100vw;\n        height: 100vh;\n        min-height: 100vh;\n        min-width: 100vw;\n        display: flex;\n        flex-direction: column;\n        background: #222;\n      }\n      header {\n        flex: 0 0 auto;\n        padding: 0;\n        margin: 0;\n        background: #181818;\n        color: #fff;\n        text-align: center;\n      }\n      .title-container {\n        margin: 0;\n        padding: 0.5em 0;\n      }\n      .webots-view-container {\n        flex: 1 1 0;\n        display: flex;\n        align-items: stretch;\n        justify-content: stretch;\n        min-height: 0;\n        min-width: 0;\n      }\n      webots-view {\n        width: 100vw;\n        height: 100vh;\n        flex: 1 1 0;\n        display: block;\n        min-width: 0;\n        min-height: 0;\n      }\n    </style>\n  </head>\n  <body>\n    <div class="webots-view-container">\n      <webots-view></webots-view>\n    </div>\n    <script type="module" src="./../wwi/WebotsView.js"></script>\n    <script>\n      // 根據當前協定與主機自動組成 wss/ws 路徑\n      const wsProtocol = (window.location.protocol === "https:") ? "wss:" : "ws:";\n      const wsHost = window.location.host;\n      // 注意：此處路徑要跟 nginx location /webots_ws/ 一致\n      const defaultIp = wsProtocol + "//" + wsHost + "/webots_ws/";\n      const defaultStreamingMode = "x3d";\n      const defaultBroadcast = false;\n      const mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n      const defaultThumbnail = \'./../wwi/images/loading/default_thumbnail.png\';\n\n      // Optional: load mobile CSS if on mobile device\n      if (mobileDevice) {\n        let head = document.getElementsByTagName(\'head\')[0];\n        let mobileCss = document.createElement(\'link\');\n        mobileCss.setAttribute(\'rel\', \'stylesheet\');\n        mobileCss.setAttribute(\'type\', \'text/css\');\n        mobileCss.setAttribute(\'href\', \'./../wwi/css/wwi_mobile.css\');\n        head.appendChild(mobileCss);\n      }\n\n      // Wait for WebotsView.js to load and custom element to be defined\n      window.addEventListener(\'DOMContentLoaded\', () => {\n        customElements.whenDefined(\'webots-view\').then(() => {\n          const webotsView = document.querySelector(\'webots-view\');\n          webotsView.onready = () => {\n            console.log("Connected to Webots streaming server!");\n          };\n          webotsView.ondisconnect = () => {\n            console.log("Disconnected from Webots streaming server!");\n          };\n          webotsView.connect(defaultIp, defaultStreamingMode, defaultBroadcast, mobileDevice, -1, defaultThumbnail);\n        });\n      });\n    </script>\n  </body>\n</html> \n auto_shoot.html \n Webots headless command: \n webots --no-rendering --stream --batch --port=1234\xa0 C:\\portable_wcm2025_big\\data\\Webots_2023b\\projects\\vehicles\\worlds\\city.wbt \n Since Webots runs in headless mode, the\xa0 --stdout \xa0 and \xa0 --stderr \xa0 arguments are used to redirect these streams from the Webots console to the console in which Webots was started, the \xa0 --batch \xa0 argument disables any blocking pop-up window and the \xa0 --mode=realtime \xa0 makes sure that the simulation is not started in pause mode (you may replace \xa0 realtime \xa0 by \xa0 fast ), finally don\'t forget to specify which simulation you want to run. \n https://www.cyberbotics.com/doc/guide/installation-procedure?version=develop#installing-the-docker-image \xa0 \n https://gist.github.com/cyberang3l/422a77a47bdc15a0824d5cca47e64ba2 \xa0 \n 與可攜系統同時啟動: \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_ipv6\nset HomeDrive=%Disk%:\\home_ipv6\nset Home=%Disk%:\\home_ipv6\nset USERPROFILE=%Disk%:\\home_ipv6\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\Python313\\DLLs;%Disk%:\\Python313\\Lib;%Disk%:\\Python313\\Lib\\site-packages;%Disk%:\\NX\\NXBIN\\python;%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin;%Disk%:\\Webots_2023b\\lib\\controller\\python;\nset PYTHONHOME=%Disk%:\\Python313\nREM for Webots\nset PYTHON_PATH=%Disk%:\\Python313\nset WEBOTS_HOME=%Disk%:\\Webots_2023b\n\nREM for putty\nset GIT_SSH=%Disk%:\\PuTTY\\plink.exe\n\nREM for Java and Android SDK\nset java_home=%Disk%:\\java\\jdk8u222-b10\nset ANDROID_SDK_home=%Disk%:\\home_ipv6\nset GRADLE_USER_home=%Disk%:\\home_ipv6\nset ANDROID_SDK_ROOT=%Disk%:\\android\\sdk\nset ANDROID_Home=%Disk%:\\android\\sdk\nset REPO_OS_OVERRIDE=windows\n\nREM 設定跟 Python 有關的命令搜尋路徑\nset path_python=%Disk%:\\Python313;%Disk%:\\Python313\\Scripts;\nREM 設定跟Git 有關的命令搜尋路徑\nset path_git=%Disk%:\\portablegit\\bin;\nREM 設定 msys2 64 位元的執行路徑\nREM %Disk%:\\msys64\\mingw64\\bin is for GD library\nset path_msys2=%Disk%:\\msys64\\ucrt64\\bin;%Disk%:\\msys64\\mingw64\\bin;\nREM set for LaTeX\nset path_miketex=%Disk%:\\miktex-portable\\texmfs\\install\\miktex\\bin\\x64;\nREM Flutter path\nset path_flutter=%Disk%:\\flutter\\bin;%java_home%\\bin;%Disk%:\\Android\\sdk;%Disk%:\\Android\\sdk\\tools;%Disk%:\\Android\\sdk\\tools\\bin;%Disk%:\\Android\\sdk\\emulator;%Disk%:\\Android\\sdk\\platform-tools;%Disk%:\\flutter\\bin\\cache\\dart-sdk\\bin;%Disk%:\\vscode;\nset path_node=%Disk%:\\node-v14.15.4-win-x64;\n\nset path_postgresql=%Disk%:\\postgresql13\\bin;\nset path_range=%Disk%:\\Range3_official\\bin;\nrem set path_range=%Disk%:\\range-3.2.5_kmol\\bin;\nset path_lua=%Disk%:\\lua-5.3.5\\;\nset path_core=%Disk%:\\coreutils-5.3.0\\bin;\nREM for gogs\nset path_putty=%Disk%:\\PuTTY;\nset path_vscode=%Disk%:\\vscode;\n\nREM for Rust\nset MINGW_PATH=%path_msys2%;\nset GIT_PATH=%path_git%;\nset VSCODE_PATH=%path_vscode%\nset RUSTUP_HOME=%Disk%:\\Rust\\rust\nset CARGO_HOME=%Disk%:\\Rust\\cargo\nset RUST_PATH=%CARGO_HOME%\\bin\n\nREM for Erlang and Elixir\nset path_erlang=%Disk%:\\elixir\\erl10.7\\bin\\;%Disk%:\\elixir\\erl10.7\\erts-10.7\\bin;%Disk%:\\elixir\\elixir\\bin;\nset ERTSPATH=%Disk%:\\elixir\\erl10.7\\erts-10.7\\bin\nset ERLINI=%Disk%:\\elixir\\erl10.7\\erts-10.7\\bin\\erl.ini\n\nREM for Haskell\nset path_haskell=%Disk%:\\ghc-9.0.1-x86_64-unknown-mingw32\\bin;\nREM for node.js\nset path_nodejs=%Disk%:\\node-v14.17.2-x64\\nodejs;%Disk%:\\node-v14.17.2-x64\\nodejs\\node_modules\\npm;\n\nREM 加入 PostgreSQL 所需的環境變數設定\n\n@SET PGDATA=%Disk%:\\postgresql13\\data\n@SET PGDATABASE=postgres\n@SET PGUSER=postgres\n@SET PGPORT=5432\n@SET PGLOCALEDIR=%Disk%:\\postgresql13\\share\\locale\n\nREM for Range3\nREM REG IMPORT %Disk%:\\range3.reg\n\nREM proxy needed for heroku login\nREM proxy can not use with fossil scm\nREM proxy can not use with Rust installation\nREM needed for node.js\nREM set HTTP_PROXY=http://[2001:288:6004:xx::42]:3128\nREM set HTTPS_PROXY=http://[2001:288:6004:xx::42]:3128\n\nREM for PyRep\nset VREP_PATH=%Disk%:\\CoppeliaSim\n\nREM BOOST_ROOT for compiling coppeliasim but maybe not for linking\nREM set BOOST_ROOT=%Disk%:\\boost_1_76_0\\;\nset path_copsim=%Disk%:\\boost_1_76_0\\;%Disk%:\\Strawberry\\perl\\bin;%Disk%:\\cmake-3.21.0-windows-x86_64\\bin;%Disk%:\\diffutils-2.8.7-1\\bin;%Disk%:\\patch-2.5.9-7\\bin;%D%:\\jom_1_1_2;%Disk%:\\LLVM\\bin;%Disk%:\\QtCreator\\bin;%Disk%:\\CoppeliaSimEdu;%Disk%:\\Python313\\tcl\\tcl8.6;\n\nREM for CMake\nset CMAKE_C_COMPILER=%Disk%:\\msys64\\ucrt64\\bin\\gcc;\nset CMAKE_CXX_COMPILER=%Disk%:\\msys64\\ucrt64\\bin\\g++;\n\nREM set QT_QPA_PLATFORM_PLUGIN_PATH=Y:\\msys64_20240507\\mingw64\\share\\qt5\\plugins\\platforms\nREM set QT_PLUGIN_PATH=Y:\\msys64_20240507\\mingw64\\share\\qt5\\plugins\n\nREM for execute scite directly\nset path_scite=%Disk%:\\wscite\\;\n\nREM for simExtZMQ\nset path_xsltproc=%Disk%:\\xsltproc;\n\nREM for OpenSSL\nSet OPENSSL_CONF=%Disk%:\\OpenSSL-Win64\\SSL\\openssl.cnf\nset path_openssl=%Disk%:\\OpenSSL-Win64\\bin;\n\nREM for textract\nset path_poppler=%Disk%:\\poppler-24.07.0\\Library\\bin;\n\nREM for tiny C compiler\nset path_tcc=%Disk%:\\tcc;\n\nREM for webots\nset  path_webots=%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin;%Disk%:\\Webots_2023b\\msys64\\usr\\bin\n\nREM for blender\nset path_blender=%Disk%:\\Blender 4.2;\n\npath=%Disk%:;%path_python%;%path_git%;%path_copsim%;%path_msys2%;%path_miketex%;%path_flutter%;%path_node%;%path_tcc%;%path_postgresql%;%path_range%;%path_lua%;%path_core%;%path_putty%;%path_vscode%;%RUST_PATH%;%path_erlang%;%path_nodejs%;%path_haskell%;%path_scite%;%path_xsltproc%;%path_gnuplot%;%path_openssl%;%path_poppler%;%path_webots%;%path_blender%;%path%;\n\nREM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@your_server\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%Disk%:\\NX\\\nset UGII_TMP_DIR=%Disk%:\\NX\\temp\nset UGII_LIB_PATH=%Disk%:\\NX\\NXBIN\\python\nset ugii=%Disk%:\\NX\\ugii;%Disk%:\\NX\\nxbin;\npath = %ugii%;%path%\nREM Xcopy %Disk%:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y\n\nREM start ugraf -nx\n\nREM python %Disk%:\\tmp\\nx_ex\\new_part.py\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite\\SciTE.exe\n\nREM start webotsw.exe\n\nstart webots.exe --no-rendering --minimize --stream --stdout --stderr --batch --mode=realtime --port=1234  C:\\portable_wcm2025_big\\data\\Webots_2023b\\projects\\vehicles\\worlds\\city.wbt\nstart webots.exe --no-rendering --minimize --stream --stdout --stderr --batch --mode=realtime --port=1235  C:\\Webots_server\\webots_projects\\cd2025_final_project_w17\\worlds\\w17_auto_loop.wbt\n\n\nExit\n \n', 'tags': '', 'url': 'Clouds.html'}, {'title': 'Talks', 'text': 'https://www.theconstruct.ai/webots-robot-simulator-ros-olivier-michel/ \xa0 \n', 'tags': '', 'url': 'Talks.html'}, {'title': 'Blender', 'text': 'Blender:  https://www.blender.org/ \n https://github.com/cyberbotics/blender-webots-exporter \xa0 \n', 'tags': '', 'url': 'Blender.html'}, {'title': 'Ardupilot', 'text': 'https://ardupilot.org/dev/docs/sitl-with-webots-cpp.html \xa0 \n https://ardupilot.org/rover/index.html \xa0 \n', 'tags': '', 'url': 'Ardupilot.html'}, {'title': 'Tutorial', 'text': 'Webots 執行環境硬體需求: \n 2GHz 4 核心以上 CPU, NVIDIA 或 AMD 支援 OpenGL 3.3 版, 帶有 512 MB 記憶體以上獨立顯示卡 \n 操作系統: \n Windows 10 或 11 64 位元操作系統 \n Ubuntu 24.04 以上版本 \n macOS 12 以上版本操作系統 \n 使用介面: \n Webots 可以透過 Tools - Preferences - Language 中選擇使用 English 或簡體中文介面 (目前無繁體中文介面, 介面語系翻譯請參考  translations 頁面 說明), 在此強烈建議使用 English 界面即可. \n \n Webots 原始碼使用授權: 採  Apache 2.0 license agreement . Apache 2.0 是一種開放且對企業友善的授權條款, 允許任何人免費使用、修改和分享軟體的原始程式碼, 包括商業用途使用. \n 自行編譯 Webots 請參考  building Webots 頁面 說明. \n Webots 套件中的大部分範例模擬檔案都使用 Apache 2.0 許可釋出, 但有部分機器人和物件模型（proto 檔案）則是根據  Webots 資產的開放原始碼許可協議 發佈, 另外有些範例則是由用戶根據不同的開源許可證所提供, 這些檔案都會明確標示其許可證內容. \n \n Webots 介紹: (查英英字典:  https://www.merriam-webster.com/dictionary/ ) \n What is Webots? \n What can I do with Webots? \n Webots simulation \n What is a world? \n What is a controller? \n What is a supervisor controller? \n Webots Crash Course  (速成班教學影片) \n https://github.com/felipenmartins/Robotics-Simulation-Labs \xa0 \n \n 第一個 Webots 導引:  https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots \n 登入 Github, 在  https://github.com/copilot  的協助下執行此一教學練習. \n 導引目的: You will create your first simulation containing a simple environment: an arena with floor and walls, a few boxes, an e-puck robot and a controller program that will make the robot move. \n 建立一個簡單的模擬環境, 意即一個競技場中, 包括一個帶有地板、圍牆、幾個盒子、一個 e-puck 機器人, 以及能讓機器人移動的控制程式. \n \n 開啟 Webots 前, 請下載  cad_data.7z  (包括 NX2312、Blender4.2 與 Webots2023b，4.2GB). \n 有關 Webots 在 Windows 操作系統啟動, 請參考 說明 . 有關 Web streaming 也請參考 說明 . \n Webots 的可執行檔案位於 Y:\\Webots_2023b\\msys64\\mingw64\\bin\\Webotsw.exe, 配置時, 若希望在不上網的情況下執行官方範例, 則必須再預先下載\xa0 https://github.com/cyberbotics/webots/releases/tag/R2023b \xa0中的\xa0 assets-R2023b.zip , 存入 Y:\\home_ipv6\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets 目錄, 否則啟動官方範例時, 必須從官方網站下載各範例中所導入的原型節點資料. \n 若 Webotsw.exe 並非是在可攜程式的環境中啟動, 則 Webots 啟動後所下載的原型節點資料, 將會存入操作系統中的 C:\\Users\\%USERNAME%\\AppData\\Local\\Cyberbotics\\Webots\\cache\\assets 目錄中. \n 在可攜程式環境中啟動 Webots 的設定: \n start_ipv6.bat 中納入: \n REM for webots set\xa0 path_webots=%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin;%Disk%:\\Webots_2023b\\msys64\\usr\\bin \n 並將 %path_webots% 放入 PATH 環境變數設定中. \n 若希望在執行 start_ipv6.bat 時開啟 Webots, 可以在啟動可攜程式的批次檔案中加入 start webotsw.exe \n 在可攜程式環境中 (USB 固態硬碟、一般隨身碟、筆電或個人電腦) 啟動 Webots 後, 開始建立模擬世界(即場景), 而在 Webots 中所謂場景: \n A  World  is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called  Nodes  and are organized hierarchically in a  Scene Tree . Therefore, a node may contain sub-nodes. A world is stored in a file having the  .wbt  extension. The file format is derived from the\xa0 VRML97  language, and is human readable. The world files must be stored directly in a directory called  worlds . \n Webots 場景中包含以下定義: \n \n 物件所在位置 \n 物件的外形 \n 物件如何互動 \n 天空的顏色 \n 地心引力的定義 \n 摩擦力 \n 物件的質量 \n 模擬的起始條件 \n 其他有關模擬的設定等 \n \n 場景中的物件稱為節點, 各節點配置於場景樹中, 各節點可以再包含子節點, 場景的檔案格式源自 VRML97 程式語法 ( VRML Primer and Tutorial ), 場景的檔案副檔名為 .wbt, 且一定要存入名稱為 worlds 的目錄中. \n Webots 模擬選單功能說明:  https://cyberbotics.com/doc/guide/the-user-interface#simulation-menu  其中著色選單可以關閉場景中的畫面, 主要配合基因演算、視覺辨識或機器學習流程中的快速模擬流程. \n', 'tags': '', 'url': 'Tutorial.html'}, {'title': 'Stage1', 'text': '學習利用 Webots 建立模擬場景的第一階段工作, 是認識其套件功能表與場景所需的目錄及檔案架構. 並且學習如何利用控制器程式操縱場景中的物件. 這也是  Tutorial1  操作的主要目的. \n worlds 儲存 .wbt 場景檔案 \n protos 儲存 .proto 原形節點檔案 \n controllers 儲存控制器程式檔案 \n plugins 儲存用來延伸 Webots 物理特性的 C 或 C++ 程式檔案, 例如:  physics.c \n libraries 儲存場景中與 controllers 或 plugins 目錄中相關程式的共用程式庫檔案 \n Tutorial2  則說明如何使用 Webots 內建的基本幾何物件, 其中的物件幾何外形除了用於動力系統的運動方程式, 還可用於物體移動時的碰撞檢測. 建立物件時必須遵照 Solid - Shape -\xa0geometry 的樹狀結構規劃, 按照順序配置物件. \n 其中 Solid - Shape - geometry Box 可以直接使用內建的幾何節點定義零件外形, 而 Solid - Shape - geometry Mesh 則可以導入自行繪製的 STL 或 OBJ 零件檔案, 而 Solid - CadShape 也可以導入 OBJ 零件檔案, 與 geometry Mesh 的差別為 Solid - Shape - geometry Mesh 可以直接在 Webots 中設定零件顏色, 而 Solid - CadShape 則由 OBJ 伴隨的 .mtl 決定其顏色與材質. \n', 'tags': '', 'url': 'Stage1.html'}, {'title': 'Tutorial1', 'text': '導引課程 本章的目的是解說 Webots 的基本概念，這些概念是自行創建模擬場景 (.wbt) 時必須用到的。學習重點在於熟悉機器人及其環境的模型建構流程，以及機器人控制器 (controllers) 的程式設計。進而學習如何尋找額外的教學資料。 本章適合 Webots 的初學者。不過，仍然需要有程式設計 (Programming) 的背景。範例是用 Python 語言編寫的。如果您不熟悉 Python 語言，透過基本說明應該還是能夠理解本章的控制器寫法，因為下面的 Python 程式非常簡單。除了程式設計，您不需要任何特定的知識即可完成本章中的教程。然而，基本的機器人學 (Robotcs)、數學 (Mathematics)、模型建構 (Modeling) 和樹狀表示法 (Tree representation) 的背景知識可能會有所幫助。有經驗的 Webots 使用者可以跳過最初的教程。不過，我們建議至少能花點時間閱讀這些教程的介紹和結論。 本章的每個部分（除了第一和最後一部分）都是一個導引課程。每個導引課程都有一個明確的教育目標，並在第一段中進行解釋。獲得的概念隨後會在結論子部分中總結。每一個導引課程都被設計成一系列互動操作步驟。要繼續進行下一個教程，通常需要掌握前一個教學中獲得的知識。因此，我們強烈建議按照導引所安排的順序進行。此外，我們建議在繼續進一步之前，確保已經理解了導引課程中的所有概念。 最後一部分將提供一些解決本章未涉及問題的提示。 導引課程的解決方案位於 Webots 安裝目錄的 "WEBOTS_HOME/projects/samples/tutorials" 子目錄中。 \n 導引課程 1：在 Webots 中進行首次模擬 目標 本導引課程的目標是讓您熟悉用戶界面和 Webots 的基本概念。您將創建一個包含簡單環境的首次模擬：一個帶有地板和牆壁的競技場、幾個箱子、一個 e-puck 機器人和一個使機器人移動的控制程式。 步驟 1. 啟動 Webots：在您的電腦上打開 Webots (假如使用協同產品設計課程的可攜套件，啟動後在命令列中輸入 webotsw 即可開啟 Webots, 若要同時啟動串流伺服器，則可輸入 webotsw --stream，之後可利用瀏覽器在伺服器的 IP 位址上以串流內建埠號 1234 連接觀看場警)。 \n 實作 #1：通過雙點擊 Webots 圖標（或在終端中從命令行調用）來啟動 Webots。如果您是第一次在此電腦上運行 Webots，可能會提示您選擇圖形主題。您也可能被邀請參加 Webots 指導遊覽，請關閉指導遊覽。 \n 2. 創建新世界： \xa0\xa0\xa0 - 轉到 File -> New World。 \xa0\xa0\xa0 - 使用適當的名稱保存新世界文件，例如 my_first_simulation.wbt。 \n 3. 添加競技場： \xa0\xa0\xa0 - 在場景樹中，右鍵點擊 root 並選擇 Add New -> Solid。 \xa0\xa0\xa0 - 將新固體重命名為 arena 並為其添加 Shape。 \xa0\xa0\xa0 - 將其幾何形狀設置為 Box，並設置適當的尺寸（例如，1m x 1m x 0.01m）來表示地板。 \xa0\xa0\xa0 - 為形狀添加 Material 並設置其顏色。 \n 實作 #2：通過點擊 3D 視圖的暫停按鈕來暫停當前模擬（請參閱用戶界面描述以找到按鈕）。如果主工具欄上的虛擬時間計數器停止，則模擬被暫停。從 File / New / New Project Directory... 菜單項創建一個新項目並按照說明進行： 1. 將項目目錄命名為 my_first_simulation，而不是建議的 my_project。 2. 將世界文件命名為 my_first_simulation.wbt，而不是建議的 empty.wbt。 3. 點擊所有選框，包括默認未選中的 "Add a rectangle arena"。 \n 4. 添加牆壁： \xa0\xa0\xa0 - 重複該過程以在競技場周圍添加四面牆壁。 \xa0\xa0\xa0 - 調整它們的位置和尺寸以適合地板周圍。 \n 實作 #3：在場景樹中雙擊 RectangleArena 節點。這應該會打開該節點並顯示其字段。 1. 選擇 floorTileSize 字段並將其值設置為 0.25 0.25 而不是 0.5 0.5。您應該立即在 3D 視圖中看到效果。 2. 選擇 wallHeight 字段並將其值更改為 0.05 而不是 0.1。競技場的牆壁現在應該變得更低。 \n 5. 添加箱子： \xa0\xa0\xa0 - 在競技場內添加幾個箱子作為障礙物。 \xa0\xa0\xa0 - 根據您的喜好設置它們的位置和尺寸。 \n 實作 #4：在場景樹中雙擊 RectangleArena 以將其關閉並選中它。點擊場景樹頂部的添加按鈕。在打開的對話框中，選擇 PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid)。一個大箱子應該會出現在競技場的中央。在場景樹中雙擊它以打開其字段。 1. 將其尺寸更改為 0.1 0.1 0.1 而不是 0.6 0.6 0.6。 2. 將其平移更改為 0 0 0.05 而不是 0 0 0.3。或者，您可以使用 3D 視圖中出現的藍色箭頭來調整其 translation.z 字段。 3. 現在按住 Shift 鍵並在 3D 視圖中拖動箱子，將其移動到競技場的某個角落。 4. 選擇箱子並按 ctrl-C，ctrl-V（Windows，Linux）或 ⌘ command-C，⌘ command-V（macOS）來複製和粘貼它。按住 Shift 鍵並拖動新箱子將其移動到某個不同的位置。以這種方式創建第三個箱子。 5. 移動箱子，使競技場中央沒有箱子。您也可以使用藍色旋轉箭頭沿垂直軸旋轉箱子。這也可以通過按住 Shift 鍵並用右鍵拖動來完成。或者，您可以更改場景樹中 WoodenBox 節點的旋轉字段的角度。 6. 一旦您對結果滿意，請使用保存按鈕保存世界。 \n 6. 添加 e-puck 機器人： \xa0\xa0\xa0 - 在場景樹中，右鍵點擊 root 並選擇 Add New -> Robot。 \xa0\xa0\xa0 - 從可用機器人列表中選擇 e-puck 機器人。 \n 實作 #5：選擇場景樹視圖中的最後一個節點 WoodenBox。點擊場景樹視圖頂部的添加按鈕。在對話框中，選擇 PROTO nodes (Webots Projects) / robots / gctronic / e-puck / E-puck (Robot)。一個 e-puck 機器人應該會出現在競技場的中央。像移動和旋轉箱子一樣移動和旋轉這個機器人。保存模擬並按下實時運行按鈕。 \n 7. 創建控制程式： \xa0\xa0\xa0 - 在場景樹中右鍵點擊 e-puck 並選擇 Add New -> Controller。 \xa0\xa0\xa0 - 選擇以 Python 程式語法創建一個新的控制器文件（例如，epuck_controller.py）並編寫一個簡單的程式來使機器人移動。例如： \n from controller import Robot, Motor  # 從 controller 模組導入 Robot 和 Motor 類別\n\nTIME_STEP = 64  # 設置時間步長為 64 毫秒\n\n# 創建 Robot 實例\nrobot = Robot()\n\n# 擷取電機設備\nleftMotor = robot.getDevice(\'left wheel motor\')  # 獲取左側輪子電機設備\nrightMotor = robot.getDevice(\'right wheel motor\')  # 獲取右側輪子電機設備\n\n# 設置電機的目標位置\nleftMotor.setPosition(10.0)  # 設置左側輪子電機的目標位置為 10.0\nrightMotor.setPosition(10.0)  # 設置右側輪子電機的目標位置為 10.0\n\nwhile robot.step(TIME_STEP) != -1:  # 當機器人步進時間步長不等於 -1 時（模擬仍在運行）\n    pass  # 什麼也不做，保持循環運行 \n 8. 保存並運行模擬： \xa0\xa0\xa0 - 保存您的世界文件。 \xa0\xa0\xa0 - 點擊 Play 按鈕運行模擬並觀察機器人移動。 結論 在本導引課程中，您已經學習了如何在 Webots 中創建一個簡單的模擬，包括添加競技場、牆壁、障礙物和 e-puck 機器人。您還創建了一個基本的控制程式來使機器人移動。本導引課程已經為您探索 Webots 更進階功能提供了充實的基礎。 \n', 'tags': '', 'url': 'Tutorial1.html'}, {'title': 'Tutorial2', 'text': '導引課程 2：修改環境 在本導引課程中，我們將教您如何在環境中創建簡單的物件。第一步將是創建一個與環境互動的球。我們將處理與節點相關的幾個概念：它們的含義是什麼，如何創建它們，它們如何必須隸屬等等。此外，我們還將看到如何設置物理效果。 將介紹幾種節點類型。它們的詳細定義可以在 參考手冊 中找到。將 節點圖表 放在您面前，將有助於理解節點的繼承關係。 \n 一個新的模擬 首先，我們基於教程 1 中創建的模擬來創建一個新的模擬。 \n 實作 #1：確保 my_first_simulation.wbt 世界文件已打開，並且模擬已暫停且虛擬時間為 0。使用 File / Save World As... 菜單將模擬保存為 obstacles.wbt。 \n 修改地板 內定的 RectangleArena PROTO 定義了一個簡單的地板，固定在靜態環境中，沒有物理節點，四周則被牆壁包圍。Webots 物件庫中還有其他預製的地板。我們現在將刪除 RectangleArena 節點，並添加一個簡單的地板，稍後在本教程中我們將手動用牆壁圍繞它。 \n 實作 #2：要刪除 RectangleArena，請在 3D 視圖或場景樹視圖中選中它，然後按鍵盤上的 del 鍵。或者，您可以在 3D 視圖中右鍵單擊它，然後在上下文菜單中選擇 Delete（您也可以直接在場景樹視圖中使用上下文表單）。選擇 TexturedBackgroundLight 節點並點擊添加按鈕。在打開的對話框中，選擇 PROTO nodes (Webots Projects) / objects / floors / Floor (Solid)。 \n 新添加的 Floor PROTO 默認大小為 10 米 x 10 米，但可以通過更改相應的欄位 (field) 來調整其大小、位置和紋理。 \n 實作 #3：在場景樹視圖中選擇並展開 Floor。修改 size 欄位並將其設置為 {1, 1} 以將其調整為 1 米 x 1 米。 \n Solid  節點 本小節介紹了 Webots 中最重要的基礎節點： Solid  節點，許多其他節點都從它衍生而來。 Solid  節點代表剛體 ，即可以忽略變形的物體。剛體中任意兩點之間的距離無論外力如何作用，都保持恆定。例如桌子、機器人手指骨節或輪子都是剛體。軟體和關節物體不是剛體。例如繩子、輪胎、海綿或關節機器人手臂都不是剛體。然而，一個關節實體可以被分解成若干剛體。 Webots 的物理引擎設計用於模擬剛體。設計模擬時，一個重要的步驟是將各種實體分解為單獨的剛體。 要定義剛體，您需要創建一個  Solid  節點。在此節點內，您將設置對應於剛體特性的不同子節點。下圖描述了一個剛體及其子節點。 Solid  節點的圖形表示由填充其子級列表的形狀節點定義。碰撞範圍在其 boundingObject 欄位中定義。圖形表示和碰撞形狀通常但不必然相同。最後， physics 欄位定義物體屬於動態環境還是靜態環境 。所有這些子節點都是可選的，但 physics 欄位設定時，需要同時定義 boundingObject。 \n \n 在 Webots 中，最簡單的剛體模型具有 幾何外形圖示  (以 Shape 中的 Geometry 標示其 視覺外形 )、 物理邊界形體  (以 boundingObject 中的 Geometry 標示其 碰撞檢測外形 ) 並處於 動態環境  (以 physics 中的 Physics 標示其 物理特性參數 ) 中。 圖中的幾何框代表任何類型的幾何原始體。事實上，它可以被替換為球體、盒子、圓柱體等。 \n 創建一個球 我們現在將在模擬中添加一個球。該球將被建模為剛體，如下圖所示。我們將使用  Sphere  節點來定義我們球的幾何形狀。 \n 實作 #4：在場景樹視圖中，選擇最後一個節點並按「Add」按鈕。在對話框中，打開「Bases nodes」部分並選擇「 Solid 」節點。在場景樹視圖中，展開「 Solid 」節點並選擇其「children」欄位。使用「Add」按鈕向其添加一個「 Shape 」節點。選擇「 Shape 」節點的「appearance」欄位，並使用「Add」按鈕添加一個「PBRAppearance」節點。 \xa0\xa0\xa0 添加一個「Sphere」節點作為新創建的「 Shape 」節點的幾何欄位。 \xa0\xa0\xa0 展開「PBRAppearance」節點，將其「metalness」欄位更改為 0，並將其「roughness」欄位更改為 1。 \xa0\xa0\xa0 向「 Solid 」的「boundingObject」欄位添加另一個「 Sphere 」節點。 \xa0\xa0\xa0 最後，向「 Solid 」的「physics」欄位添加一個「Physics」節點。 \xa0\xa0\xa0 通過修改「 Solid 」節點的「translation」欄位，將球放置在機器人前面（例如在 {0.2, 0, 0.2}）。 \xa0\xa0\xa0 保存模擬。 \xa0\xa0\xa0 結果如下圖所示。 \n \n 你的第一個 Webots 剛體 當模擬開始時，球會撞擊地板。您可以通過對球施加力來移動它（ctrl + alt + 左鍵單擊並拖動）。通過啟用 View / Optional Rendering / Show Contact Points 表單項，可以顯示球與地板之間的接觸點作為青色線條。 \n 幾何體 為了定義球，我們在兩個不同的上下文中使用了 Sphere 節點：圖形表示 (graphical representation)（children）和定義物理邊界 (physical bounds)（boundingObject）。所有幾何節點（例如 Sphere 節點）都可以在圖形標示中使用。但是，只有其中的一部分可以在物理標示中使用。 節點圖表 中則明確指出哪些節點可以用在何種標示。(這裡需要進一步說明各節點的適用情境) 我們現在將縮小球體的尺寸，並通過增加用於表示它的三角形數量來提高其圖形質量。 \n 實作 #5：對於定義球的每個 Sphere 節點，將其 radius 欄位設置為 0.05，將其 subdivision 欄位設置為 2。請參考  sphere 手冊 了解 subdivision 欄位的含義。 \n DEF-USE 機制 DEF-USE 機制允許在一個地方定義一個節點，並在場景樹的其他地方重用該定義。這對於避免在世界文件中重複相同的節點非常有用。此外，它還允許用戶同時修改多個對象。其工作原理如下：首先使用 DEF 字符串標記一個節點。然後可以使用 USE 關鍵字在其他地方重用該節點的副本。只有 DEF 節點的欄位可以編輯，USE 節點的欄位繼承自 DEF 節點，無法更改。此機制依賴於世界文件中節點的順序。DEF 節點應在任何相應的 USE 節點之前定義。 我們之前用來定義球的兩個 Sphere 定義是冗餘的。我們現在將使用 DEF-USE 機制將這兩個 Sphere 合併為一個。 \n 實作 #6：在場景樹視圖中選擇第一個 Sphere 節點（Shape 的子節點）。場景樹視圖的欄位編輯器允許您輸入 DEF 字符串。 \xa0\xa0\xa0 在此欄位中輸入 BALL_GEOMETRY。 \xa0\xa0\xa0 選擇 boundingObject 欄位（包含第二個 Sphere 節點），通過右鍵單擊該欄位並選擇彈出上下文菜單中的「Delete」條目來清空它。 \xa0\xa0\xa0 然後，選擇 boundingObject 欄位並單擊「Add」按鈕，在對話框中選擇 USE / BALL_GEOMETRY。 \xa0\xa0\xa0 結果如圖所示。 \n 現在，更改第一個 Sphere 節點的 radius 欄位也會修改其 boundingObject。 為了方便起見，boundingObject 欄位也接受  Shape  節點（而不是直接接受 Sphere 節點）。同樣可以在  Shape  層級使用相同的 DEF-USE 機制，如下圖所示。目前最大的好處是能夠直接將此  Shape  用於圖形目的。稍後此機制對於某些傳感器將非常有用。 \n \n 在名為 BALL_GEOMETRY 的 Sphere 節點上使用 DEF-USE 機制。 \n \n 在 Solid 的 幾何體的 Sphere 節點上應用 DEF-USE 機制 。 \n 實作 #7：創建第二個球，使用相同的參數，但使用  Shape  節點（而不是直接使用 Sphere 節點）來實現 DEF-USE 機制。 \n 添加牆壁 為了驗證您的進展，請自行實現四面牆來圍繞環境。這些牆必須靜態地定義到環境中。為了理解靜態和動態之間的區別，讓我們取一個地面上的定義物體（球）。如果 Physics 節點為 NULL，它將在模擬期間保持靜止在空中（靜態情況）。如果 physics 欄位包含 Physics 節點，它將在重力作用下掉落（動態情況）。 儘量在 Shape  層級使用 DEF-USE 機制，而不是在 Geometry 層級。確實，將中間 Shape 節點添加到 Solid 節點的 boundingObject 欄位中更方便。實現牆壁的最佳幾何原語是  Box  節點。所有牆壁只需定義一個  Shape 。預期結果如圖所示。 \n 實作 #8：添加四面牆，無需物理效果，並且只使用一個 Shape 節點的定義。 \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請進入您的文件並找到在 導引課程1 中創建的名為 "my_first_simulation" 的文件夾，然後進入 "worlds" 文件夾並用文本編輯器打開相應的世界文件。此解決方案與其他解決方案位於 solution 目錄中。 \n \n 在本教程結束時的模擬狀態。 \n 效率 剛體的模擬計算代價高昂。通過最小化邊界對象的數量、最小化它們之間的約束（有關約束的更多信息在後續教程中），以及最大化 WorldInfo.basicTimeStep 欄位，可以提高模擬速度。在每次模擬中，必須在模擬速度和現實感之間找到權衡。 \n 結論 在本教程結束時，您將能夠基於剛體創建簡單的環境。您能夠從場景樹視圖中添加節點並修改其欄位。您已經熟悉了  Solid 、Physics、 Shape 、Sphere 和  Box  節點。您還看到了 DEF-USE 機制，該機制允許減少場景樹的節點冗餘。 \n', 'tags': '', 'url': 'Tutorial2.html'}, {'title': 'Stage2', 'text': 'Webots 進入第二階段，包含零件的外觀 ( Tutorial3 )，控制與感測 ( Tutorial4 )，以及複合外形零件的建構 ( Tutorial5 ) 等議題. \n 利用  Tutorial5  中的 Group 節點，可配合 CAD 套件轉出的零組件，整合出更複雜外形的模擬場景。 \n 使用 CAD 套件繪製機構所需零件，因為在組立時各零件已經完成定位，因此使用上，只要透過 Solid -  CadShape  導入 obj 格式的零件檔案，或使用 Solid - Shape - Mesh (導向 obj 或 stl 格式檔案) 即可在模擬場景中套用，至於各連桿  Solid  節點中的 boundingObject 欄位, 只要利用  Mesh  節點中的 url 指向物件 obj 或 stl 檔案即可. \n 另外\xa0 hingeJoint  中的  HingeJointParameters  則宣告該轉軸所在位置 (anchor) 以及旋轉軸向量 (axis) 即可. \n Plotter 中驅動馬達的模擬，則必須使用  Tutorial4  中的控制與感測技術. \n', 'tags': '', 'url': 'Stage2.html'}, {'title': 'Tutorial3', 'text': '導引課程 3：外觀 本導引課程的目的是讓你熟悉一些與圖形著色 (rendering) 相關的節點。當這些節點被適當使用時，可以很快創建出外觀良好的模擬。良好的圖形質量不僅能提升用戶體驗，對於機器人感知其環境的模擬（如攝像頭圖像處理、循線等）也是至關重要的。 本教學結束時的效果如下圖所示。 \n \n 新模擬 \n 實作 #1：創建新模擬 從上一個教程的結果中，通過使用檔案 / 另存世界... 菜單創建一個名為 "appearance.wbt" 的新模擬。 \n 燈光 世界的燈光由燈光節點 ( Light ) 和背景 ( Background ) 決定。燈光節點有三種類型：方向燈 ( DirectionalLight )、單點燈 ( PointLight ) 和聚光燈 ( SpotLight )。方向燈模擬無限遠的光源（例如：太陽），點燈模擬從單一點發出的光（例如：燈泡），而聚光燈模擬錐形光（例如：手電筒）。下面這張圖展示了它們之間的比較。每種類型的燈光節點都可以投射陰影。你可以在 參考手冊 中找到它們的完整文檔。 \n \n 三種在 Webots 中可能的燈光比較。左邊是方向燈 (DirectionalLight)，中間是聚光燈 (SpotLight)，右邊是點燈 (PointLight)。 \n 在模擬中設置燈光就性能上需要耗費運算資源，會降低模擬速度（尤其是在投射陰影時）。最小化燈光數量可以提高渲染速度。單點燈 (PointLight) 比聚光燈 (SpotLight) 更高效，但比方向燈 (DirectionalLight) 效率低。 在本次模擬中，燈光節點在場景樹中不可見，因為它包含在  TexturedBackgroundLight  PROTO 節點中。它由一個方向燈 (DirectionalLight) 組成，其強度和方向根據場景背景自動計算。 修改牆壁的外觀 本小節的目標是將牆壁顏色改為藍色。 形狀節點 ( Shape ) 的外觀 ( Appearance ) 和 PBR 外觀 ( PBRAppearance ) 節點決定了物件的圖形外觀。在其他方面，這些節點負責物件的顏色和紋理。 如以下比較所示，建議使用 PBR 外觀以獲得更好的渲染效果。 \n \n 外觀節點 (Appearance) 和 PBR 外觀節點 (PBRAppearance) 的比較。左邊是外觀節點 (Appearance)，右邊是 PBR 外觀節點 (PBRAppearance)。 \n PBRAppearance 節點指定了一個節點的基於物理的視覺外觀。縮寫 "PBR" 指的是 "Physically-Based Rendering"（基於物理的渲染），這個術語用來表示一類基於物體物理特性的著色模型，而不是像在 Appearance 節點中使用的 Blinn-Phong BRDF 這樣的更古老的模型。 \n Blinn–Phong  反射模型，也稱為修改的 Phong 反射模型，是由  Jim Blinn  開發的  Phong 反射模型 的修改版本。 Blinn–Phong 是一種在 OpenGL 和 Direct3D 的固定功能管線（在 Direct3D 10 和 OpenGL 3.1 之前）中使用的著色模型，並在每個頂點上進行處理，當它通過圖形管線時；頂點之間的像素值默認由  Gouraud  著色插值，而不是計算成本更高的  Phong  著色。 \n 實作 #2：在圖形表示第一面牆的形狀節點 (Shape) 中，將 PBRAppearance 節點添加到外觀 (Appearance) 欄位。 - 使用顏色選擇器將其 baseColor 欄位設置為藍色。 - 使用欄位編輯器將其 metalness 欄位設置為 0。 - 最後，使用欄位編輯器將其 roughness 欄位設置為 0.5。 - 如果上一個教程中的 DEF-USE 機制正確實施，所有牆壁應該都會變成藍色。 \n 添加現有的外觀到球體 Webots 發行版中提供了許多預定義的 PBRAppearance。 \n 實作 #3：添加預定義的 PBRAppearance \xa0\xa0\xa0 選擇外觀 (appearance) 欄位並刪除之前添加的節點。要刪除此節點，可以按鍵盤上的 "delete" 鍵，或右鍵點擊該欄位並從菜單中選擇 "delete"。此欄位現在應顯示為 "appearance NULL" 而不是 "appearance PBRAppearance"。 \xa0\xa0\xa0 再次雙擊該欄位，然後導航到 PROTO 節點 (Webots Projects)，再導航到 appearances，並選擇 OldSteel (PBRAppearance)。 \n 添加硬碟中儲存的紋理 本小節的目標是將本地可用的紋理應用到球上。在滾動的物體加上紋理可更容易檢視其運動情況。 \n 實作 #4：將本地可用的紋理添加到球體。 1. 下載 這裡 所提供的紋理並將其儲存到硬碟中。 2. 從外觀 (appearance) 欄位中刪除先前添加的節點，並改為添加一個 PBRAppearance 節點。 3. 向 PBRAppearance 節點的 baseColorMap 欄位添加一個 ImageTexture 節點。 4. 使用 "Add" 按鈕向 ImageTexture 的 url 欄位添加一個項目。 5. 然後使用 "Select" 按鈕設置新添加的 url 項目的值。 6. 跟隨路徑到您保存紋理的位置並選擇它。 \n 紋理 URL 必須定義為相對於專案目錄的 worlds 目錄或相對於預設專案目錄 WEBOTS_HOME/projects/default/worlds。 在圖像查看器中打開 red_brick_wall.jpg 紋理，同時觀察它如何映射到 Webots 中的 Sphere 節點上。 紋理根據參考手冊中描述的預定義 UV 映射函數映射到幾何節點上。UV 映射函數將 2D 圖像表示映射到 3D 模型。 \n \n 在設置好 Light 和 PBRAppearance 節點後的模擬。 \n 渲染選項 Webots 在視圖菜單中提供了幾種渲染模式。 \n 實作 #5：使用"視圖 / 線框渲染" (View / Wireframe Rendering) 表單項以線框模式查看模擬。然後還原為普通渲染模式："視圖 / 普通渲染" (View / Plain Rendering)。 \n 其他渲染功能也很有幫助： \xa0\xa0\xa0 查看座標系統： View / Optional Rendering / Show Coordinates System 或使用 ctrl-F1 \xa0\xa0\xa0 查看距離傳感器光線： View / Optional Rendering / Show DistanceSensor Rays 或使用 ctrl-F10 \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請轉到您的文件並找到在  Tutorial1 中創建的名為 my_first_simulation 的文件夾，然後轉到 worlds 文件夾並使用文本編輯器打開正確的世界文件。 此解決方案 和其他解決方案位於 解決方案目錄 中。 結論 在本導引課程中，您學習了如何使用  PBRAppearance  節點和光源節點設置一個美觀的環境。 您可以通過閱讀參考手冊中這些節點的詳細描述來進一步了解此主題。此 常見問題 解答將為您提供有效設置這些節點的方法。 \n', 'tags': '', 'url': 'Tutorial3.html'}, {'title': 'Distancesensor', 'text': 'https://cyberbotics.com/doc/reference/distancesensor \n Derived from  Device  and  Solid . \n DistanceSensor {\n  MFVec3f  lookupTable              [ 0 0 0, 0.1 1000 0 ] # lookup table\n  SFString type                     "generic"             # {"generic", "infra-red", "sonar", "laser"}\n  SFInt32  numberOfRays             1                     # [1, inf)\n  SFFloat  aperture                 1.5708                # [0, 2*pi]\n  SFFloat  gaussianWidth            1                     # [0, inf)\n  SFFloat  resolution               -1                    # {-1, [0, inf)}\n  SFFloat  redColorSensitivity      1                     # [0, inf)\n} \n 在 Webots 的 DistanceSensor 設為紅外線（Infra-red, IR）模式時，lookupTable 欄位用於將感測器的原始輸出值（通常是類比值，例如AD值或電壓）對應到實際的距離（通常以米為單位）。這個對應關係並非線性，且會根據不同的紅外線感測器型號而有所不同，因此需要用 lookupTable 明確設定。 \n lookupTable 的格式說明 lookupTable 是一串三元組（triplet）組成的陣列，每個三元組代表： \n [distance, value, standardDeviation] \n distance：真實世界對應的距離（單位：公尺）。 value：感測器輸出的原始值（通常為電壓或AD值）。 standardDeviation：該點測量的誤差標準差（單位：公尺，非必需，可設為0）。 \n 第一欄：輸入的距離（distance，單位：公尺） 第二欄：對應的感測器反應值（response value，通常是電壓或 AD 值） 第三欄：對應的標準差（standard deviation） \n 例如: \n lookupTable [ \xa0 0.05 100 0.01 \xa0 0.20 400 0.01 \xa0 0.80 800 0.01 ] \n 這代表： 當輸出值為 100 時，對應距離為 0.05 公尺。 當輸出值為 400 時，對應距離為 0.20 公尺。 ... 以此類推。 Webots 會用這些點做線性內插，將感測器讀數（例如 350）對應到距離。 \n \xa0設定 lookupTable 的方法 查閱感測器手冊：取得原廠提供的「輸出值 vs 距離」對照表。 選擇幾個代表性數值：通常選 3~5 組即可覆蓋感測範圍。 將其填入 lookupTable： \n 使用 lookupTable 設定的意義 lookupTable 告訴 Webots「當感測器輸出某值時，應該對應到什麼距離」。 因為紅外線測距不是線性的，所以線性內插比直接計算更準確。 這讓模擬更貼近真實感測器行為。 \n', 'tags': '', 'url': 'Distancesensor.html'}, {'title': 'Tutorial4', 'text': "導引課程 4：更多關於控制器的內容 現在我們開始討論與編程機器人控制器相關的主題。我們將設計一個簡單的控制器來避開在前面的教程中創建的障礙物。 本教程將介紹 Webots 中機器人編程的基礎。在本章結束時，您應該了解場景樹節點與控制器 API 之間的關聯，如何初始化和清理機器人控制器，如何初始化機器人設備，如何獲取傳感器值，如何指令執行器，以及如何編程一個簡單的反饋迴路。 本教程僅涉及 Webots 功能的正確使用。機器人算法的研究超出了本教程的目標，因此不會在此處討論。掌握一些基本的編程知識是解決本章問題的必要條件（任何 C 教程應該都是足夠的入門介紹）。在本章的末尾，提供了進一步的機器人算法的鏈接。 \n 新的模擬場景與控制器 \n 實作 #1：將之前的世界保存為 collision_avoidance.wbt。從文件/新建/新建機器人控制器菜單項中創建一個新的 C（或任何其他語言）控制器，命名為 epuck_avoid_collision（對於 C++ 和 Java，命名為 EPuckAvoidCollision）。修改 E-puck 節點的控制器欄位以將其與新控制器關聯。 \n Hands on #1: Save the previous world as collision_avoidance.wbt. Create a new C (or any other language) controller called epuck_avoid_collision (for C++ and Java call it EPuckAvoidCollision instead) from the File / New / New Robot Controller... menu item. Modify the controller field of the E-puck node in order to associate it to the new controller. \n Reminder: How to create a new controller? Select the File / New / New Robot Controller... menu item and choose your programming language and the file name. \n 了解 e-puck 模型 控制器編程需要一些與 e-puck 模型相關的信息。為了創建碰撞檢測算法，我們需要讀取其炮塔周圍的 8 個紅外距離傳感器的值，並且我們需要驅動其兩個輪子。下圖展示了距離傳感器在炮塔周圍的分佈情況以及 e-puck 的方向。 距離傳感器在機器人層次結構中由 8 個  DistanceSensor  節點建模。這些節點通過它們的名稱欄位進行引用（從 ps0 到 ps7）。我們將在稍後解釋這些節點是如何定義的。目前，只需注意可以通過 Webots API 的相關模塊訪問 DistanceSensor 節點（通過 webots/distance_sensor.h 標頭文件）。距離傳感器返回的值在 0 到 4096 之間縮放（線性分段到距離）。4096 表示測量到大量光（障礙物很近），而 0 表示沒有測量到光（沒有障礙物）。 控制器 API 是一個編程接口，它使您能夠訪問機器人的模擬傳感器和執行器。例如，包含 webots/distance_sensor.h 文件允許使用 wb_distance_sensor_* 函數，通過這些函數可以查詢 DistanceSensor 節點的值。API 函數的文檔可以在 參考手冊 中找到，並附有每個節點的描述。 \n \n e-puck 模型的上視圖。綠色箭頭表示機器人的前方。紅色線條代表紅外距離傳感器的方向。字符串標籤對應於距離傳感器的名稱。 \n \n 簡單回饋迴路的 UML 狀態機 \n 編寫控制器程序 我們想要編程一個非常簡單的碰撞避免行為。您將編程使機器人向前行駛，直到前方距離傳感器檢測到障礙物，然後轉向無障礙物的方向。為了做到這一點，我們將使用在圖中的 UML 狀態機中所示的簡單反饋迴路。 此控制器的完整代碼在下一小節中給出。 \n 動手操作 #2：在控制器文件的開頭，添加對應於 Robot、DistanceSensor 和 Motor 節點的導入指令，以便能夠使用相應的 API： from controller import Robot, DistanceSensor, Motor 在導入語句之後，定義一個變量，用於定義每個物理步長的持續時間。這個宏將用作 Robot::step 函數的參數，它也將用於啟用設備。這個持續時間以毫秒為單位，必須是 WorldInfo 節點的 basicTimeStep 欄位值的倍數。 TIME_STEP = 64 \n 主函數是控制器程序開始執行的地方。傳遞給主函數的參數由 Robot 節點的 controllerArgs 欄位給出。必須使用 wb_robot_init 函數初始化 Webots API，並使用 wb_robot_cleanup 函數清理它。 \n 動手操作 #3：在 Python 中沒有主函數，程序從文件的開始處開始執行： \n # create the Robot instance.\nrobot = Robot()\n# initialize devices\n# feedback loop: step simulation until receiving an exit event\nwhile robot.step(TIME_STEP) != -1:\n    # read sensors outputs\n    # process behavior\n    # write actuators inputs \n 機器人設備由 WbDeviceTag 引用。WbDeviceTag 由 wb_robot_get_device 函數檢索。然後，它在每個涉及此設備的函數調用中用作第一個參數。像 DistanceSensor 這樣的傳感器在使用前必須啟用。enable 函數的第二個參數定義了傳感器的刷新率。 \n 動手操作 #4：在註釋 // initialize devices 之後，獲取並啟用距離傳感器，如下所示： \n # initialize devices\nps = []\npsNames = [\n    'ps0', 'ps1', 'ps2', 'ps3',\n    'ps4', 'ps5', 'ps6', 'ps7'\n]\n\nfor i in range(8):\n    ps.append(robot.getDevice(psNames[i]))\n    ps[i].enable(TIME_STEP) \n 初始化設備後，初始化馬達： \n leftMotor = robot.getDevice('left wheel motor')\nrightMotor = robot.getDevice('right wheel motor')\nleftMotor.setPosition(float('inf'))\nrightMotor.setPosition(float('inf'))\nleftMotor.setVelocity(0.0)\nrightMotor.setVelocity(0.0) \n 在主循環中，在註釋 # read sensors outputs 之後，按如下方式讀取距離傳感器的值： \n # read sensors outputs\npsValues = []\nfor i in range(8):\n    psValues.append(ps[i].getValue()) \n 在主循環中，在註釋 # process behavior 之後，檢測是否發生碰撞（即距離傳感器返回的值大於閾值），如下所示： \n # detect obstacles\nright_obstacle = psValues[0] > 80.0 or psValues[1] > 80.0 or psValues[2] > 80.0\nleft_obstacle = psValues[5] > 80.0 or psValues[6] > 80.0 or psValues[7] > 80.0 \n 最後，使用有關障礙物的信息來驅動車輪，如下所示： \n MAX_SPEED = 6.28\n...\n# initialize motor speeds at 50% of MAX_SPEED.\nleftSpeed  = 0.5 * MAX_SPEED\nrightSpeed = 0.5 * MAX_SPEED\n# modify speeds according to obstacles\nif left_obstacle:\n    # turn right\n    leftSpeed  = 0.5 * MAX_SPEED\n    rightSpeed = -0.5 * MAX_SPEED\nelif right_obstacle:\n    # turn left\n    leftSpeed  = -0.5 * MAX_SPEED\n    rightSpeed = 0.5 * MAX_SPEED\n# write actuators inputs\nleftMotor.setVelocity(leftSpeed)\nrightMotor.setVelocity(rightSpeed) \n Save your code by selecting the File / Save Text File menu item. Reload the world. \n 控制器代碼 以下是前一小節中詳細介紹的控制器完整代碼。 \n from controller import Robot, DistanceSensor, Motor\n\n# time in [ms] of a simulation step\nTIME_STEP = 64\n\nMAX_SPEED = 6.28\n\n# create the Robot instance.\nrobot = Robot()\n\n# initialize devices\nps = []\npsNames = [\n    'ps0', 'ps1', 'ps2', 'ps3',\n    'ps4', 'ps5', 'ps6', 'ps7'\n]\n\nfor i in range(8):\n    ps.append(robot.getDevice(psNames[i]))\n    ps[i].enable(TIME_STEP)\n\nleftMotor = robot.getDevice('left wheel motor')\nrightMotor = robot.getDevice('right wheel motor')\nleftMotor.setPosition(float('inf'))\nrightMotor.setPosition(float('inf'))\nleftMotor.setVelocity(0.0)\nrightMotor.setVelocity(0.0)\n\n# feedback loop: step simulation until receiving an exit event\nwhile robot.step(TIME_STEP) != -1:\n    # read sensors outputs\n    psValues = []\n    for i in range(8):\n        psValues.append(ps[i].getValue())\n\n    # detect obstacles\n    right_obstacle = psValues[0] > 80.0 or psValues[1] > 80.0 or psValues[2] > 80.0\n    left_obstacle = psValues[5] > 80.0 or psValues[6] > 80.0 or psValues[7] > 80.0\n\n    # initialize motor speeds at 50% of MAX_SPEED.\n    leftSpeed  = 0.5 * MAX_SPEED\n    rightSpeed = 0.5 * MAX_SPEED\n    # modify speeds according to obstacles\n    if left_obstacle:\n        # turn right\n        leftSpeed  = 0.5 * MAX_SPEED\n        rightSpeed = -0.5 * MAX_SPEED\n    elif right_obstacle:\n        # turn left\n        leftSpeed  = -0.5 * MAX_SPEED\n        rightSpeed = 0.5 * MAX_SPEED\n    # write actuators inputs\n    leftMotor.setVelocity(leftSpeed)\n    rightMotor.setVelocity(rightSpeed) \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請轉到您的文件並找到在  Tutorial1  中創建的名為 my_first_simulation 的文件夾，然後轉到 worlds 文件夾並使用文本編輯器打開正確的世界。此解決方案與其他解決方案位於解決方案目錄中。 結論 以下是您剛剛學到的關鍵點的快速摘要： - 控制器入口點是主函數，就像任何標準的 C 程序一樣。 - 在調用 wb_robot_init 函數之前，不應調用任何 Webots API 函數。 - 離開主函數之前要調用的最後一個函數是 wb_robot_cleanup 函數。 - 設備由其設備節點的名稱欄位引用。可以通過 wb_robot_get_device 函數檢索節點的引用。 - 每個控制器程序都作為 Webots 進程的子進程執行。控制器進程不與 Webots 共享任何內存（除了相機的圖像），並且它可以在與 Webots 不同的 CPU（或 CPU 核心）上運行。 - 控制器代碼鏈接到 libController 動態庫。該庫處理控制器與 Webots 之間的通信。 本節更詳細地解釋了控制器編程。您應該仔細閱讀以進一步了解在 Webots 中的機器人編程。 \n", 'tags': '', 'url': 'Tutorial4.html'}, {'title': 'Tutorial5', 'text': '導引課程 5：複合固體和物理屬性 \n 本導引課程的目的是通過創建一個具有多個邊界對象的固體來更詳細地探索物理模擬：一個由兩個球體和一個圓柱體組成的啞鈴。預期結果如圖所示。 \n \n 預期結果在教程結束時，您將能夠創建一個由兩個球體和一個圓柱體組成的啞鈴，如圖所示。 \n 新的模擬 \n 實作練習 #1：從上一個教程的結果開始，並通過使用表單 File / Save World As.... 創建一個名為 compound_solid.wbt 的新模擬。 \n Compound Solid \n It is possible to build  Solid  nodes more complex than what we have seen before by aggregating  Shape  nodes. In fact, both the physical and the graphical properties of a  Solid  can be made of several  Shape  nodes. Moreover each  Shape  node can be placed in a  Pose  node in order to change its relative position and orientation.  Group  nodes can also be used to group several sub-nodes. \n We want to implement a dumbbell made of a handle ( Cylinder ) and of two weights ( Sphere ) located at each end of the handle. This  figure  depicts the  Solid  nodes and its sub-nodes required to implement the dumbbell. \n Hands on #2: Create the dumbbell by following the figure. Create the handle first without placing it in a Pose node (so the handle axis will have the same direction as the z-axis of the solid). The handle should have a length of 0.1 m and a radius of 0.01 m. The weights should have a radius of 0.03 m and a subdivision of 2. The weights can be moved at the handle extremities thanks to the translation field of their Pose nodes. \n \n representation of the subnodes of a compound solid made of several transformed geometries. \n Physics Attributes \n The aim of this subsection is to learn how to set some simple physics properties for a  Solid  node. The  Physics  node contains fields related to the physics of the current rigid body ( Solid ). \n The  mass  of a  Solid  node is given by its  density  or  mass  field. Only one of these two fields can be specified at a time (the other should be set to  -1 ). When the  mass  is specified, it defines the total mass of the solid (in [kg]). When the  density  is specified, its value (in [kg/m3]) is multiplied by the volume of the bounding objects, and the product gives the total mass of the solid. A density of 1000 [kg/m³] corresponds to the density of water (default value). \n Hands on #3: Set the mass of the dumbbell to 2 [kg]. The density is not used and should be set to -1. \n By default, the  center of mass  of a  Solid  node is set at its origin (defined by the translation field of the solid). The center of mass can be modified using the  centerOfMass  field of the  Physics  node. The center of mass is specified relatively to the origin of the  Solid . \n Hands on #4: Let\'s say that one of the weights is heavier than the other one. Move the center of mass of the dumbbell of 0.01 [m] along the z-axis. \n Note that when the solid is selected, the center of mass is represented in the 3D view by a coordinate system which is darker than the coordinate system representing the solid center. \n The Rotation Field \n The  rotation  field of the  Pose  node determines the rotation of this node (and of its children) using the  Euler axis and angle  representation. A  Euler axis and angle  rotation is defined by four components. The first three components are a unit vector that defines the rotation axis. The fourth component defines the rotation angle about the axis (in [rad]). \n The rotation occurs in the sense prescribed by the right-hand rule. \n Hands on #5: Modify the rotation of the Solid node of the dumbbell in order to move the handle\'s axis (z-axis) parallel to the ground. A unit axis (0, 1, 0) and an angle of π/2 (~ 1.5708) is a possible solution. \n How to Choose Bounding Objects? \n As said before, minimizing the number of bounding objects increases the simulation speed. However, choosing the bounding objects primitives carefully is also crucial to increase the simulation speed. \n Using a combination of  Sphere ,  Box ,  Capsule  and  Cylinder  nodes for defining objects is very efficient. Generally speaking, the efficiency of these primitives can be sorted like this:  Sphere  >  Box  >  Capsule  >  Cylinder , where the  Sphere  is the most efficient. But this can be neglected under common usage. \n The  IndexedFaceSet  geometry primitive can also be used in a bounding object. But this primitive is less efficient than the other primitives listed above. Moreover its behavior is sometimes buggy. For this reasons, we don\'t recommend using the  IndexedFaceSet  when another solution using a combination of the other primitives is possible. \n Grounds can be defined using the  Plane  or the  ElevationGrid  primitives. The  Plane  node is much more efficient than the  ElevationGrid  node, but it can only be used to model a flat terrain while the  ElevationGrid  can be used to model an uneven terrain. \n Contacts \n When two solids collide,  contacts  are created at the collision points.  ContactProperties  nodes can be used to specify the desired behavior of the contacts (e.g. the friction between the two solids). \n Each solid belongs to a material category referenced by their  contactMaterial  field ( default  by default). The  WorldInfo  node has a  contactProperties  field that stores a list of  ContactProperties  nodes. These nodes allow to define the contact properties between two categories of  Solids . \n We want now to modify the friction model between the dumbbell and the other solids of the environment. \n Hands on #6: Set the contactMaterial field of the dumbbell to "dumbbell". In the WorldInfo node, add a ContactProperties node between the default and dumbbell categories. Try to set the coulombFriction field to 0 and remark that the dumbbell slides (instead of rotating) on the floor because no more friction is applied. \n basicTimeStep ,  ERP  and  CFM \n The most critical parameters for a physics simulation are stored in the  basicTimeStep ,  ERP  and  CFM  fields of the  WorldInfo  node. \n The  basicTimeStep  field determines the duration (in [ms]) of a physics step. The bigger this value is, the quicker the simulation is, the less precise the simulation is. We recommend values between  8  and  16  for regular use of Webots. \n It\'s more difficult to explain the behavior of the  ERP  and  CFM  fields. These values are directly used by the physics engine to determine how the constraints are solved. The default values are well defined for regular use of Webots. We recommend to read the  Reference Manual  and the documentation of  ODE  (physics engine used in Webots) to understand completely their purpose. \n Minor Physics Parameters \n There are also other physics parameters which are less useful in a regular use of Webots, for example some of the fields of the  Physics ,  WorldInfo  and  ContactProperties  nodes. \n Hands on #7: Search how to add a linear damping on all the objects, how to use the inertia matrix and how to use the physicsDisableTime property. \n Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in  Tutorial 1 , then go to the "worlds" folder and open with a text editor the right world.  This solution  as the others is located in the  solution directory . \n Conclusion \n You are now able to build a wide range of solids including those being composed of several rigid bodies. You know that a Geometry node can be moved and rotated if it is included in a  Pose  node. You are aware about all the physics parameters allowing you to design robust simulations. The next step will be to create your own robot. \n You can test your skills by creating common objects such as a table. \n', 'tags': '', 'url': 'Tutorial5.html'}, {'title': 'Stage3', 'text': 'Tutorial6  是學習如何建立及控制行動機器人. \n Tutorial7  說明如何自行建立原型物件 (PROTO). \n Tutorial8  就自行開發投籃機模擬場景而言, 可在虛擬的模擬場景中, 利用 supervisor 模式配置非可實際達成的程式控制加速虛實產品的開發流程. \n', 'tags': '', 'url': 'Stage3.html'}, {'title': 'Tutorial6', 'text': 'Tutorial 6: 4-Wheeled Robot \n This tutorial aims at creating your first robot from scratch. The robot will consist of a body, four wheels, and two distance sensors. The result is depicted on  this figure . The  next figure  shows the robot from a top view. \n \n 3D view of the 4 wheels robot. Note that the coordinate system representations of the robot body and of its wheels are oriented the same way. Their +x-vector (in red) defines the left of the robot, their +y-vector (in green) defines the top of the robot, and their +z-vector (in blue) defines the front of the robot. The distance sensors are oriented in a different way, their +x-vector indicates the direction of the sensor. \n \n Top view of the 4 wheeled robot. The grid behind the robot has a dimension of 0.2 x 0.3 meters. The text labels correspond to the name of the device. \n New Simulation \n \n Hands on #1 : Save the world of the previous tutorial as \xa0 4_wheeled_robot.wbt . Remove the nodes defining the e-puck, the ball, the dumbbell and the contact properties. The ground, the walls and the lighting are kept. \n \n Separating the Robot in Solid Nodes \n Some definitions and rules to create the robot model: \n \n \n The set containing the \xa0 Solid \xa0 node and all its derived nodes are called the \xa0 solid nodes . \n \n \n A similar definition is applied for the \xa0 Device , \xa0 Robot , \xa0 Joint \xa0 and \xa0 Motor \xa0 nodes. You can get more information about the node hierarchy in the \xa0 nodes chart diagram . \n \n \n Most sensors and actuators are both \xa0 Solid \xa0 and \xa0 Device \xa0 nodes at the same time. \n \n \n The main structure of a \xa0 Robot \xa0 model is a tree of \xa0 Solid \xa0 nodes linked together. The root node of this tree should be a \xa0 Robot \xa0 node. \n \n \n The solids are linked together by \xa0 Joint \xa0 nodes. A \xa0 Device \xa0 node should be the direct child of either a \xa0 Robot \xa0 node, a \xa0 Solid \xa0 node or a \xa0 Joint \xa0 node. \n \n \n A \xa0 Joint \xa0 node is used to add one (or two) degree(s) of freedom (DOF), between its parent and its child. The direct parent and child of a \xa0 Joint \xa0 node are both \xa0 Solid \xa0 nodes. \n \n \n The nodes derived from \xa0 Joint \xa0 allow creating different kinds of constraints between the linked \xa0 Solid \xa0 nodes. The most used one in robotics, is the \xa0 HingeJoint \xa0 allowing to model amongst others rotational motors including wheels. \n \n \n A \xa0 Joint \xa0 node can be monitored or actuated by adding a \xa0 PositionSensor \xa0 node, or a motor node to its \xa0 device \xa0 field respectively. \n \n \n Having these rules in mind, we can start designing the node hierarchy used to model the robot. The first step is to determine which part of the robot should be modeled as a \xa0 Solid \xa0 node. \n In our example, this operation is quite obvious. The robot has 4 DOF corresponding to the wheel motors. It can be divided in five solid nodes: the body and the four wheels. \n Depending on the expected application of the robot model, reducing the DOF while modelling might be necessary to get an efficient simulation. For example, when modeling a caster wheel, a realistic approach implies to model 2 DOF. But if this degree of precision is useless for the simulation, a more efficient approach can be found. For example, to model the caster wheel as a \xa0 Sphere \xa0 having a null friction coefficient with the ground. \n The second step is to determine which \xa0 Solid \xa0 node is the \xa0 Robot \xa0 node (the root node). This choice is arbitrary, but a solution is often much easier to implement. For example, in the case of a humanoid robot, the robot node would be typically the robot chest, because the robot symmetry facilitates the computation of the joint parameters. \n In our case, the body box is obviously the better choice. The \xa0 figure \xa0 depicts the solid nodes hierarchy of the robot. \n \n Hands on #2 : At the end of the scene tree, add a \xa0 Robot \xa0 node having four \xa0 HingeJoint \xa0 nodes having a \xa0 Solid \xa0 node as \xa0 endPoint . Please refer to \xa0 this figure . Add a \xa0 Shape \xa0 node containing a Box geometry to the \xa0 Robot \xa0 node. Set the color of the \xa0 Shape \xa0 to red. Use the \xa0 Shape \xa0 to define the \xa0 boundingObject \xa0 field of the \xa0 Robot \xa0 node. The dimension of the box is \xa0 (0.2, 0.1, 0.05) . Add a \xa0 Physics \xa0 node to the \xa0 Robot . The \xa0 figure \xa0 represents all the nodes defining the robot. So far, only the direct children nodes of the root \xa0 Robot \xa0 node has been implemented. \n \n \n High level representation of the 4 wheeled robot \n HingeJoint \n The initial position of the wheel is defined by the translation and the rotation fields of the \xa0 Solid \xa0 node. \n The rotation origin (anchor) and the rotation axis (axis) are defined by the optional \xa0 HingeJointParameters \xa0 child of the \xa0 HingeJoint \xa0 node. \n \n Representation of a hinge joint \n The radius of the wheel is 0.04 and its thickness (height of the cylinder) is 0.02. For the first wheel, the \xa0 Solid \xa0 translation should be defined to \xa0 (0.05, 0.06, 0) \xa0 in order to define the relative gap between the body and the wheel, and the rotation to \xa0 (1 0 0 1.5708) \xa0 for the wheel cylinder to be correctly oriented. The \xa0 HingeJointParameters \xa0 anchor should also be defined to \xa0 (0.05, 0.06, 0) \xa0 to define the rotation origin (relatively to the body). Finally, the \xa0 HingeJointParameters \xa0 axis should define the rotation axis. In our case it\'s along the y-axis (so \xa0 (0, 1, 0) ). \n \n Hands on #3 : Add a \xa0 HingeJointParameters \xa0 node, and enter the field values as described above. Some signs obviously have to be updated for other wheels. \n \n Now, let\'s implement the cylinder shape of the wheels. \n For each \xa0 HingeJoint , there are three fields in which nodes need to be added. \n \n jointParameters : Add a \xa0 HingeJointParameters \xa0 and configure the anchor (0.05 -0.06 0) and axis (0 1 0) fields. These values have to be modified according to the location of the wheel. \n device : Add a \xa0 RotationalMotor \xa0 in order to be able to actuate the wheels. Change their \xa0 name \xa0 fields from \xa0 wheel1 \xa0 to \xa0 wheel4 \xa0 according to \xa0 this figure . These labels will be used to reference the wheels from the controller. \n endPoint : Add a \xa0 Solid \xa0 node, then a \xa0 Shape \xa0 node in the \xa0 children \xa0 field of the \xa0 Solid , and finally, add a \xa0 Cylinder \xa0 in the \xa0 geometry \xa0 field of the \xa0 Shape \xa0 node. The \xa0 Cylinder \xa0 should have a \xa0 radius \xa0 of \xa0 0.04 \xa0 and a \xa0 height \xa0 of \xa0 0.02 . Set the color of the wheels to green. \n \n \n Hands on #4 : Complete the missing nodes to get the same structure as the \n one depicted in \xa0 this figure . Don\'t forget the \xa0 Physics \xa0 nodes. \n \n \n Low level representation of the 4 wheeled robot \n Sensors \n The sensors used on the e-puck of \xa0 Tutorial 4 \xa0 are not the same as the ones used in this section. Pay attention to their measuring interval which is between \xa0 0 cm = 0 \xa0 and \xa0 10 cm = 1000 . Find more information about the \xa0 lookupTable \xa0 field \xa0 here . \n The last part of the robot modeling is to add the two distance sensors to the robot. This can be done by adding two \xa0 DistanceSensor \xa0 nodes as direct children of the \xa0 Robot \xa0 node. Note that the distance sensor acquires its data along the positive x-axis. So, it is necessary to rotate the distance sensor to point their x-axis outside the robot (see the \xa0 figure ). \n \n \n \n \n \n \n \n \n \n \n \n \n \n Reminder : How to know the orientation of the distance sensor? As already says in \xa0 Tutorial 3 , the distance sensor rays can be viewed using the shortcut \xa0 ctrl - F10 \xa0 or \xa0 View / Optional Rendering / Show DistanceSensor Rays .\n \n Hands on #5 : Add the two distance sensors as explained above. The distance sensors are at an angle to 0.3 [rad] with the front vector of the robot. Set the graphical and physical shape to a cube (not transformed) having a edge of \xa0 0.01 \xa0 [m]. Set the color to blue. Set the \xa0 name \xa0 field according to the labels of \xa0 this figure . \n \n Tips : How to precisely orient distance sensors? In the \xa0 DistanceSensor \xa0 node, the rotation field has 4 parameters. If you set the angle parameter to 0, then you can use the mouse wheel to increment/decrement by steps of 0.1309 rad (= 7.5 degree).\n Controller \n In the previous tutorials, you have learnt how to setup a feedback loop and how to read the distance sensor values. However, actuating a \xa0 RotationalMotor \xa0 node is something new. To program the rotational motors, the first step is to include the API module corresponding to the \xa0 RotationalMotor \xa0 node: \n \n from  controller  import  Motor\n \n \n Then to get the references of the \xa0 RotationalMotor \xa0 nodes: \n \n # initialize motors \nwheels = []\nwheelsNames = [ \'wheel1\' ,  \'wheel2\' ,  \'wheel3\' ,  \'wheel4\' ]\n for  name  in  wheelsNames:\n    wheels.append(robot.getDevice(name))\n \n \n A \xa0 Motor \xa0 can be actuated by setting its position, its velocity, its acceleration or its force. Here we are interested in setting its velocity. This can be achieved by setting its position to infinity, and by bounding its velocity: \n \n speed =  -1.5    # [rad/s] \nwheels[ 0 ].setPosition(float( \'inf\' ))\nwheels[ 0 ].setVelocity(speed)\n \n \n \n Hands on #6 : Implement a controller called \xa0 four_wheeled_collision_avoidance \xa0 moving the robot and avoiding obstacles by detecting them by the distance sensors. \n \n Note that the \xa0 lookupTable \xa0 field of the \xa0 DistanceSensor \xa0 nodes indicates the values returned by the sensor. To help in the debugging with the sensors, it is possible to see the value of the sensors in the real-time in the \xa0 robot-window . To open the \xa0 robot-window , double-click on the robot body and it will bring up a menu on the left with the \xa0 DistanceSensor \xa0 and \xa0 RotationalMotor \xa0 graph. Run the simulation to see the evolution. \n Don\'t forget to set the \xa0 controller \xa0 field of the \xa0 Robot \xa0 node to indicate your new controller. \n As usual a possible solution of this exercise is located in the tutorials directory. \n The Controller Code \n Here is the complete code of the controller developed in the previous subsection. \n from controller import Robot\n\nTIME_STEP = 64\nrobot = Robot()\nds = []\ndsNames = [\'ds_right\', \'ds_left\']\nfor i in range(2):\n    ds.append(robot.getDevice(dsNames[i]))\n    ds[i].enable(TIME_STEP)\nwheels = []\nwheelsNames = [\'wheel1\', \'wheel2\', \'wheel3\', \'wheel4\']\nfor i in range(4):\n    wheels.append(robot.getDevice(wheelsNames[i]))\n    wheels[i].setPosition(float(\'inf\'))\n    wheels[i].setVelocity(0.0)\navoidObstacleCounter = 0\nwhile robot.step(TIME_STEP) != -1:\n    leftSpeed = 1.0\n    rightSpeed = 1.0\n    if avoidObstacleCounter > 0:\n        avoidObstacleCounter -= 1\n        leftSpeed = 1.0\n        rightSpeed = -1.0\n    else:  # read sensors\n        for i in range(2):\n            if ds[i].getValue() < 950.0:\n                avoidObstacleCounter = 100\n    wheels[0].setVelocity(leftSpeed)\n    wheels[1].setVelocity(rightSpeed)\n    wheels[2].setVelocity(leftSpeed)\n    wheels[3].setVelocity(rightSpeed) \n Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in \xa0 Tutorial 1 , then go to the "worlds" folder and open with a text editor the right world. \xa0 This solution \xa0 as the others is located in the \xa0 solution directory . \n Conclusion \n You are now able to design simple robot models, to implement them and to create their controllers. \n More specifically, you learnt all the different nodes involved in the design of a robot model, methods to translate and rotate a solid relative to another and the way that a rotational motor is actuated by the controller. \n', 'tags': '', 'url': 'Tutorial6.html'}, {'title': 'Tutorial7', 'text': 'Tutorial 7: Your First PROTO \n The aim of this tutorial is to create a PROTO file corresponding to the four wheels robot from the previous tutorial. \n Copy the Robot Definition \n For now, the definition of the robot is completely contained in the world file. Moving this definition in a PROTO file will allow you to use this robot without the need to completely copy and paste its definition (either several times in the same world or in different worlds). \n \n Hands-on #1 : Open the world \xa0 4_wheels_robot.wbt \xa0 created in the previous tutorial in your favorite text editor. Create a new empty text file in the \xa0 protos \xa0 folder of your project called \xa0 FourWheelsRobot.proto \xa0 and open this file in the text editor too, this file will contain the definition of your robot. \n \n Any PROTO file should at least respect the following structure: \n #VRML_SIM R2025a utf8\nPROTO protoName [\n  protoFields\n]\n{\n  protoBody\n} \n The \xa0 protoName \xa0 should be the name of the PROTO file (i.e. \xa0 FourWheelsRobot \xa0 in this case), \xa0 protoFields \xa0 defines the modifiable fields of the PROTO node (this part should be empty for now) and the \xa0 protoBody \xa0 is the definition of the root node (i.e. the \xa0 Robot \xa0 node in this case). \n \n Hands-on #2 : Write this default structure in your PROTO file with the correct \xa0 protoName . From the \xa0 4_wheels_robot.wbt \xa0 world file copy the robot node (starting with \xa0 Robot { \xa0 and ending with the final \xa0 } ) and paste it in your PROTO file instead of the \xa0 protoBody . Finally, save the PROTO file. \n \n Solution : You should have something like this: \n #VRML_SIM R2025a utf8\n  PROTO FourWheelsRobot [\n\n  ]\n  {\n    Robot {\n      # list of fields\n    }\n  } \n Use the PROTO Node. \n This new PROTO node is now available for each world in your current project. \n \n \n Hands-on #3 : Open the \xa0 4_wheels_robot.wbt \xa0 world in Webots and add the \xa0 FourWheelsRobot \xa0 node (that you just defined). The node is located in \xa0 PROTO nodes (Current Project) / FourWheelsRobot (Robot) . \n \n A second 4 wheels robot should have been added at the exact same location as the already existing one. \n Adding Fields \n As you probably noticed, this new PROTO node doesn\'t have any open field, it is therefore impossible to translate, rotate or change the controller for example. It is very easy to add new fields to a PROTO node and to link them with internal fields. This should be done in the PROTO interface part (part between the \xa0 [ \xa0 and the \xa0 ] ). \n \n Hands-on #4 : Edit your PROTO file in your text editor and add the definition of the \xa0 translation , \xa0 rotation \xa0 and \xa0 bodyMass \xa0 field in the PROTO interface part: \n \n   field SFVec3f    translation  0 0 0\n  field SFRotation rotation     0 0 1 0\n  field SFFloat    bodyMass     1\n \n Your PROTO node has now two open fields but they are not linked to any internal field. To link the fields you should use the IS keyword, simply replace the \xa0 translation x y z \xa0 and \xa0 rotation x y z angle \xa0 fields of the \xa0 Robot \xa0 node by: \n   translation IS translation\n  rotation IS rotation\n \n And the \xa0 mass \xa0 field of the \xa0 Physics \xa0 node of the \xa0 Robot \xa0 node by: \n   mass IS bodyMass\n \n Save your PROTO file, it should now look like this: \n #VRML_SIM R2025a utf8\nPROTO FourWheelsRobot [\n  field SFVec3f    translation  0 0 0\n  field SFRotation rotation     0 0 1 0\n  field SFFloat    bodyMass     1\n]\n{\n  Robot {\n    translation IS translation\n    rotation IS rotation\n    children [\n      # list of children nodes\n    ]\n    boundingObject USE BODY\n    physics Physics {\n      density -1\n      mass IS bodyMass\n    }\n    controller "four_wheels_collision_avoidance"\n  }\n} \n You can now save your simulation in Webots and revert it. The \xa0 translation , \xa0 rotation \xa0 and \xa0 bodyMass \xa0 of the \xa0 FourWheelsRobot \xa0 node can now be changed (either in the \xa0 scene tree \xa0 or using the handles in the \xa0 3D view ). \n The same mechanism could also be used to expose the \xa0 controller \xa0 field of the \xa0 Robot \xa0 node. \n Solution: PROTO File \n To compare your PROTO file with \xa0 the solution , go to your files and find the folder named "my_first_simulation" created in \xa0 Tutorial 1 , then go to the "protos" folder and open with a text editor the right PROTO. \n Conclusion \n You are now able to create PROTO nodes from any nodes you created in Webots. \n More specifically, you learnt how to copy the node definition in the PROTO file and how to open and link PROTO fields to internal node fields. \n To go further, the \xa0 PROTO chapter \xa0 of the reference manual explains in detail all the possibilities of the PROTO mechanism. \n', 'tags': '', 'url': 'Tutorial7.html'}, {'title': 'Stream', 'text': 'https://cyberbotics.com/doc/guide/web-streaming \n Webots 透過 webotsw --stream 所啟動的串流伺服器, 僅允許連接 streaming_viewer 目錄中的 index.html, 若希望直接透過 index.html 啟動 WebSocket 連線, 就必須自行建立 WWW server. \n 以下利用 Python 程式在 port 8000 建立 WWW server, 並且執行時自動利用 Edge 連線至 index4.html 超文件. \n python_www_server.py \n import http.server\nimport socketserver\nimport threading\nimport webbrowser\nimport time\nimport os\nimport sys\nimport subprocess\n\nPORT = 8000\nDIRECTORY = os.path.dirname(os.path.abspath(__file__))\n\nclass Handler(http.server.SimpleHTTPRequestHandler):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, directory=DIRECTORY, **kwargs)\n\ndef open_edge(url):\n    # Try common Edge paths on Windows\n    edge_paths = [\n        r"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",\n        r"C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe"\n    ]\n    for path in edge_paths:\n        if os.path.exists(path):\n            subprocess.Popen([path, url])\n            return True\n    # Fallback: try using webbrowser module (may open in default browser)\n    try:\n        webbrowser.get(\'windows-default\').open(url)\n    except:\n        webbrowser.open(url)\n    return False\n\ndef run_server():\n    with socketserver.TCPServer(("", PORT), Handler) as httpd:\n        print(f"Serving at http://localhost:{PORT}")\n        httpd.serve_forever()\n\nif __name__ == "__main__":\n    # Start server in a thread\n    server_thread = threading.Thread(target=run_server, daemon=True)\n    server_thread.start()\n\n    # Wait a moment for the server to start\n    time.sleep(1)\n\n    # Open Edge to the local index.html\n    url = f"http://localhost:{PORT}/streaming_viewer/index4.html"\n    print(f"Opening {url} in Edge...")\n    open_edge(url)\n\n    # Keep main thread alive to keep server running\n    try:\n        while True:\n            time.sleep(10)\n    except KeyboardInterrupt:\n        print("Shutting down.")\n        sys.exit(0) \n index4.html \n <!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <title>Streaming viewer</title>\n    <link rel="icon" type="image/png" href="webots_icon.png">\n    <link type="text/css" rel="stylesheet" href=\'style.css\' />\n    <style>\n      html, body {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n      body {\n        width: 100vw;\n        height: 100vh;\n        min-height: 100vh;\n        min-width: 100vw;\n        display: flex;\n        flex-direction: column;\n        background: #222;\n      }\n      header {\n        flex: 0 0 auto;\n        padding: 0;\n        margin: 0;\n        background: #181818;\n        color: #fff;\n        text-align: center;\n      }\n      .title-container {\n        margin: 0;\n        padding: 0.5em 0;\n      }\n      .webots-view-container {\n        flex: 1 1 0;\n        display: flex;\n        align-items: stretch;\n        justify-content: stretch;\n        min-height: 0;\n        min-width: 0;\n      }\n      webots-view {\n        width: 100vw;\n        height: 100vh;\n        flex: 1 1 0;\n        display: block;\n        min-width: 0;\n        min-height: 0;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="webots-view-container">\n      <webots-view></webots-view>\n    </div>\n    <script type="module" src="http://localhost:8000/wwi/WebotsView.js"></script>\n    <script>\n      // Default WebSocket parameters\n      const defaultIp = "ws://localhost:1234";\n      const defaultStreamingMode = "x3d";\n      const defaultBroadcast = false;\n      const mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n      const defaultThumbnail = \'https://cyberbotics.com/wwi/R2023b/images/loading/default_thumbnail.png\';\n\n      // Optional: load mobile CSS if on mobile device\n      if (mobileDevice) {\n        let head = document.getElementsByTagName(\'head\')[0];\n        let mobileCss = document.createElement(\'link\');\n        mobileCss.setAttribute(\'rel\', \'stylesheet\');\n        mobileCss.setAttribute(\'type\', \'text/css\');\n        mobileCss.setAttribute(\'href\', \'https://www.cyberbotics.com/wwi/R2023b/css/wwi_mobile.css\');\n        head.appendChild(mobileCss);\n      }\n\n      // Wait for WebotsView.js to load and custom element to be defined\n      window.addEventListener(\'DOMContentLoaded\', () => {\n        customElements.whenDefined(\'webots-view\').then(() => {\n          const webotsView = document.querySelector(\'webots-view\');\n          webotsView.onready = () => {\n            console.log("Connected to Webots streaming server!");\n          };\n          webotsView.ondisconnect = () => {\n            console.log("Disconnected from Webots streaming server!");\n          };\n          webotsView.connect(defaultIp, defaultStreamingMode, defaultBroadcast, mobileDevice, -1, defaultThumbnail);\n        });\n      });\n    </script>\n  </body>\n</html> \n', 'tags': '', 'url': 'Stream.html'}, {'title': 'Webots Server', 'text': 'Webots Server: \n https://github.com/mdecycu/webots-server \n Webots Cloud: \n https://github.com/cyberbotics/webots-cloud \n https://cyberbotics.com/doc/guide/web-server \n', 'tags': '', 'url': 'Webots Server.html'}, {'title': 'Projects', 'text': "利用 Solvespae、NX、Onshape 或其他 CAD 套件建立下列的五軸機械臂零組件。 \n 驅動設計請採用 NEMA (National Electrical Manufacturers Association) 17 步進馬達: \n 法蘭 (Flange) 尺寸 1.7 英吋: 約 43.2 mm x 43.2 mm \n 軸心直徑: 5 mm \n 螺絲孔間距: 約 31 mm \n 長度 (厚度): 通常為 34~60 mm \n 步進角: 一般為 1.8°（每轉 200 步） \n 驅動電壓與電流: 視型號而定，常見如 12V, 1~2A \n Linkages \n https://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/ \xa0 \n 5-bar \n plotter.7z  (in Solvespace) \n \n \n \n fivebar_parallel_linkage.7z  (in Solidworks and NX2312) \n https://github.com/mdecycu/5-Bar-Parallel-Robot-Kinematics-Simulation \xa0 \n https://github.com/mdecycu/parallel-five-bar-robot \xa0 \n https://github.com/mdecycu/five_bar_linkage \xa0 \n https://github.com/mdecycu/FrostBot \n https://github.com/mdecycu/Robot-Sketcher-5-bar-parallel-manipulator- \xa0 \n https://www.researchgate.net/publication/277299749_User's_manual_for_the_DexTAR_five-bar_parallel_robot \n https://www.mathworks.com/help/sm/ug/five-bar-robot.html \n Optimal Design of a Five-Bar Planar Manipulator and Its Controller by Using Different Algorithms for Minimum Shaking Forces and Moments for the Largest Trajectory in a Usable Workspace  \n Kinematic calibration of a five-bar planar parallel robot using all working modes \n Concurrent Design of a 2 Dof Five-Bar Parallel Robot a Hybrid Design of Rigid and Flexible Links \n Kinematic Analysis of Five-Bar Mechanism.pdf \n \n \n \n Kinematic Design of Five-Bar Parallel Robot by Kinematically Defined Performance Index for Energy Consumption \n https://github.com/Phylliade/ikpy \xa0 \n https://hackaday.io/project/173325-educational-five-bar-parallel-robot \n", 'tags': '', 'url': 'Projects.html'}, {'title': 'Control', 'text': 'Essentials of Arduino Boards Programming \xa0(電子書)\xa0\xa0 \n PythonForControl.pdf \n OpenModelica  +  Pyfmi  + Webots \n 1. 在 Modelica 建立控制器: \n model SimplePIDController\n  input Real position;\n  output Real torque;\n\n  parameter Real Kp = 2.0;\n  parameter Real Kd = 0.5;\n\n  Real error;\n  Real derror;\ninitial equation\n  error = 0;\n  derror = 0;\nequation\n  error = 0 - position;\n  derror = der(error);\n  torque = Kp * error + Kd * derror;\nend SimplePIDController;\n \n 2. 匯出為 FMU \n 用 OpenModelica，匯出此模型為 FMU： \xa0 \xa0 使用 OMEdit ➜ 選擇 Export ➜ FMI \xa0 \xa0 勾選： \xa0 \xa0 \xa0 \xa0 ✔ FMU for Co-Simulation \xa0 \xa0 \xa0 \xa0 或 ✔ FMU for Model Exchange（自行利用 PyFMI 提供 solver） \n 會產生一個 .fmu 檔（zip 檔格式）。 \n 3. Webots 中撰寫 Python 控制器: \n 以便讓 Webots 的機器人由 FMU 控制。 \n from controller import Robot\nfrom pyfmi import load_fmu\n\n# Webots 設定\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\n\n# 載入 FMU 控制器\ncontroller = load_fmu("SimplePIDController.fmu")\ncontroller.initialize()\n\n# 獲取感測器與馬達\njoint_sensor = robot.getPositionSensor("my_joint_sensor")\njoint_sensor.enable(timestep)\n\nmotor = robot.getMotor("my_joint_motor")\n\nwhile robot.step(timestep) != -1:\n    position = joint_sensor.getValue()\n    \n    # 設定 FMU 輸入\n    controller.set("position", position)\n    \n    # 執行一步 FMU 模型\n    controller.do_step(current_t=robot.getTime(), step_size=timestep / 1000.0)\n    \n    # 取得輸出\n    torque = controller.get("torque")\n    \n    # 輸出至 Webots 馬達\n    motor.setTorque(torque)\n \n \n', 'tags': '', 'url': 'Control.html'}, {'title': 'Printer', 'text': '這裡所指的 Printer 是 3D 列印機。 \n 3D Printing : \n 3D printing , or \xa0 additive manufacturing , is the \xa0 construction \xa0 of a \xa0 three-dimensional object \xa0 from a \xa0 CAD \xa0 model or a digital \xa0 3D model . \xa0 It can be done in a variety of processes in which material is deposited, joined or solidified under \xa0 computer control , \xa0 with the material being added together (such as plastics, liquids or powder grains being fused), typically layer by layer. \n In the 1980s, 3D printing techniques were considered suitable only for the production of functional or aesthetic prototypes, and a more appropriate term for it at the time was \xa0 rapid prototyping . \xa0 As of 2019, the precision, repeatability, and material range of 3D printing have increased to the point that some 3D printing processes are considered viable as an industrial-production technology; in this context, the term \xa0 additive manufacturing \xa0 can be used synonymously with \xa0 3D printing .One of the key advantages of 3D printing \xa0 is the ability to produce very complex shapes or geometries that would be otherwise infeasible to construct by hand, including hollow parts or parts with internal \xa0 truss \xa0 structures to reduce weight while creating less material waste. \xa0 Fused deposition modeling \xa0 (FDM), which uses a continuous filament of a \xa0 thermoplastic \xa0 material, is the most common 3D printing process in use as of 2020. \n', 'tags': '', 'url': 'Printer.html'}, {'title': 'Otto', 'text': 'otto_robot.7z \n', 'tags': '', 'url': 'Otto.html'}, {'title': 'Otto_ninja-1', 'text': 'https://www.printables.com/model/231580-otto-ninja-starter-robot/files \xa0 \n \n', 'tags': '', 'url': 'Otto_ninja-1.html'}, {'title': 'Simplify', 'text': '以下程式碼是一個專為 Blender 設計的 Python 程式，其目的是將複雜的 3D 模型零件簡化為凸包（Convex Hull），並在簡化後保留原始物件的物理屬性，最後將簡化後的模型匯出。 由於利用 CAD 繪出的零件，轉入 Webots 進行剛體動力學模擬運算時，若能將幾何外形轉換為網格資料較為簡單的凸包，可大幅減少物理引擎的運算負擔，進而提升模擬的流暢度和穩定性。 以下是程式碼的設計原理與主要流程： 設計原理: \n 分離設定與核心邏輯：程式碼將使用者可修改的參數（如檔案路徑、格式、簡化比率）放在程式開頭的「使用者設定」區塊，而將實際執行的功能封裝在獨立的函式中。這種設計使程式易於修改和維護，使用者不需要理解複雜的內部邏輯就能快速調整參數。 模組化函式：每個函式負責一個單一且明確的任務，例如 clear_scene() 清空場景、import_all_parts() 匯入模型、get_physics_properties() 獲取物理屬性等等。這種模組化設計使程式碼結構清晰，易於除錯和理解。 穩健的錯誤處理：在 import_all_parts()、get_physics_properties() 等函式中，程式碼都包含了對異常情況（如檔案夾不存在、物件無效）的檢查和錯誤訊息輸出。這確保了腳本在遇到問題時不會無故崩潰，而是能給出有用的提示。 \n 複製-簡化-匹配三階段工作流程： \n 複製：為每個原始零件建立一個副本。這樣可以避免直接修改原始物件。 \n 簡化：對這個副本執行凸包（Convex Hull）運算。凸包是一個包含原始物體所有頂點的最小凸多面體，可以將複雜的幾何體轉化為簡單的凸體。 \n 匹配：將簡化後的凸包賦予原始物件的物理屬性，包括位置、旋轉和質量。 \n 匯出：最後，刪除原始物件，只匯出簡化後的凸包。 \n 利用 Blender scripting 簡化 OBJ 組立檔中的個別零件:\xa0 blender_simplify_obj_parts.7z \n simplify_parts_v2.py \n', 'tags': '', 'url': 'Simplify.html'}, {'title': 'OpenDuck', 'text': '登入 Onshape 後，連線至  OpenDuck mini v2 官方 Onshape  後，以滑鼠左鍵點選畫面左上方的功能表，點選 Copy workspace 後，選擇 Document name，滑鼠點選 Copy document to 中的 Owned by me，再點選下方的 Open 後，就可以取得 OpenDuck workspace 的副本。 \n \n https://github.com/apirrone/Open_Duck_Mini \xa0 \n open_duck_mini.7z \n STS3215 Onshape \n Openduck mini Onshape \xa0(必須先登入  Onshape  後才能檢視) \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'OpenDuck.html'}, {'title': 'Pupper', 'text': 'https://github.com/mangdangroboticsclub/mini_pupper_ros \xa0 \n https://www.kickstarter.com/projects/mdrobotkits/mini-pupper-2-open-source-ros2-robot-kit-for-dreamers \xa0 \n \n \n', 'tags': '', 'url': 'Pupper.html'}, {'title': 'JetAcker', 'text': 'https://github.com/NVIDIA-AI-IOT/jetracer \xa0 \n https://www.hiwonder.com/collections/robotics-1/products/jetacker \xa0 \n SMARTmBOT: \n https://arxiv.org/pdf/2203.08903 \xa0 \n https://github.com/SMARTlab-Purdue/SMARTmBOT \xa0 \n \n', 'tags': '', 'url': 'JetAcker.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束  \n \n  ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Ref', 'text': '', 'tags': '', 'url': 'Ref.html'}, {'title': 'Reeborg', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \n https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_east_west.py \xa0 \n \n https://mde.tw/reeborg \n https://github.com/mdecycu/cs101 \n https://reeborg.ca/docs/en/python/index.html \n https://aroberge.github.io/reeborg-api/ \n if using local static port 9442: \n Reeborg \n For Github Pages: \n Reeborg \n \n', 'tags': '', 'url': 'Reeborg.html'}, {'title': 'ex1', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \xa0是已知的機器人採收紅蘿蔔的程式，經由以下與 Copilot 的對話，希望透過 Python Class 的編寫解決特定範圍農作物採收的程式。 \n 問句: \n 以下是 Reeborg 一個用來採收紅蘿蔔的程式, 目前位於 (3,3) 到 (8,8) 的區域中各座標點, 各有一個紅羅蔔等待採收, 現在想要建立一個 harvest() class, 可以利用 (3,3), (8,8)作為標定有農作物必須採收的兩個區域對角點座標, 而程式可以利用此一 harvest 類別生成案例完成採收的任務: def turn(int):\n    for i in range(int):\n        turn_left()\n        \ndef new_move(int):\n    for i in range(int):\n        move()\n        \ndef harvest_one_row():\n    while object_here():\n        take()\n    else:\n        move()\n# move to the field\nnew_move(2)\nturn_left()\nnew_move(2)\n\nfor i in range(3):\n    while is_facing_north():\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn(3)\n            move() \n    else:\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn_left()\n            move() \n AI 回答:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex1.py \xa0 \n 進一步要求: \n 請在類別中加上一個採收方向的參數, 內建變數是 horizontal 採收, 也就是由西邊往東邊的水平方向進行採收, 但若該方向變數設為 vertical 則會由南邊往北的所謂垂直方向進行採收 \n AI 回應:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex2.py\xa0 \xa0 \n 延伸到採收 harvest2 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest2.json&editor=python/harvest1_class_ex1.py \xa0 \n 但卻沒能套用到 harvest3 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex1.py \xa0 \n 而必須要在每一個座標點留下或放入一個紅蘿蔔:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex3.py\xa0 \xa0 \n', 'tags': '', 'url': 'ex1.html'}, {'title': 'Otto_ninja-2', 'text': 'https://www.printables.com/model/231580-otto-ninja-starter-robot/files \xa0 \n \n', 'tags': '', 'url': 'Otto_ninja-2.html'}, {'title': 'Pyodide', 'text': 'Pyodide  是一個將  Python  解譯器和常用科學套件 (例如:  numpy 、 scipy 、 matplotlib \xa0等) 編譯成  WebAssembly ，可在瀏覽器中執行  Python \xa0程式的專案。 \n Pyodide  是將  CPython  編譯為  WebAssembly ，可在瀏覽器或其他  WebAssembly  環境中執行；而  CPython  是標準的原生  Python  解譯器，運行在作業系統上。換言之， Pyodide  是為在瀏覽器中執行  Python  而設計的  CPython  移植版本。 Pyodide \xa0可與  JavaScript  雙向互動，讓  Python  程式能呼叫  JavaScript  函數並操作網頁元素，也能被  JavaScript  呼叫執行  Python  程式碼。 \n \n \n \n version   hello   1 add to 100   機器人巡邏 自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide.html'}, {'title': 'Pyodide_ex', 'text': 'Pyodide 機器人巡邏 \xa0- 由於網頁載入場景圍牆與 Pyodide 執行機器人行走模擬的速度差異，機器人巡邏畫面的圍牆無法及時顯示。 \n 經過場景圍牆多次 (目前為 3 次) 載入 (必須配合瀏覽器 Client 端執行速度與網路傳輸速度進行調整)， Pyodide 機器人巡邏2  可以正確載入圍牆圖檔。 \n Pyodide 導入客製化模組: \n const code = `\n# 定義一個模組內容\ndef hello():\n    print("Hello from custom module!")\n`;\npyodide.runPython(code);\n \n Volume_max_pyodide_de_short.py \n Volume_max_pyodide_de.py \n \n', 'tags': '', 'url': 'Pyodide_ex.html'}, {'title': 'Pyodide2', 'text': 'Pyodide2 在頁面中導入  robot.py \xa0(註解版:  pyodide_robot_commented.py ) 後，可以直接在頁面編輯器中，直接利用 walk() 與 turn_left() 兩個方法，引導 機器人前行與左轉 。也可以在編輯器中自行 定義右轉方法 ，賦予機器人更多功能。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide2.html'}, {'title': 'robot.py', 'text': 'robot.py \n 第一段：模組匯入與常數定義 \n js 是 Brython 提供的 JS-Python 橋接模組，可直接操作 JavaScript DOM。 asyncio 是 Python 的非同步處理模組，用來讓動畫非同步進行。 CELL_SIZE 設定地圖中每個格子的大小（40px × 40px）。 WALL_THICKNESS 是用於繪製牆壁的線條厚度。 IMG_PATH 是儲存所有圖片的伺服器路徑（用於載入牆壁與機器人圖）。 \n import js, asyncio\n\n# 每個格子的像素寬度\nCELL_SIZE = 40\n\n# 牆壁的厚度（像素）\nWALL_THICKNESS = 6\n\n# 圖片資源的網址前綴\nIMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"\n \n 第二段：World 類別 – 建立世界與地圖圖層 \n World 類負責建立整個地圖畫面，並初始化所需的畫布圖層。 _image_cache 是類別層級變數，用來快取圖片物件。 \n class World:\n    _image_cache = {}  # 用來暫存載入過的圖片，避免重複下載\n\n    def __init__(self, width, height):\n        self.width = width     # 地圖寬（幾格）\n        self.height = height   # 地圖高（幾格）\n        self.layers = self._create_layers()  # 建立四個 canvas 圖層\n        self._init_html()      # 將圖層與控制按鈕加到 HTML 畫面\n \n 第三段：建立圖層 \n 這些圖層都是 canvas 元素，彼此重疊在一起，依序繪製地圖。 \n     def _create_layers(self):\n        return {\n            "grid": js.document.createElement("canvas"),    # 網格底圖\n            "walls": js.document.createElement("canvas"),   # 牆壁\n            "objects": js.document.createElement("canvas"), # 痕跡/物件\n            "robots": js.document.createElement("canvas"),  # 機器人\n        }\n \n 第四段：初始化 HTML 結構 \n 建立一個 container 容器，設定為相對定位。 將四層 canvas 疊放進容器中，每層用不同的 zIndex 疊層排序。 \n     def _init_html(self):\n        container = js.document.createElement("div")\n        container.style.position = "relative"\n        container.style.width = f"{self.width * CELL_SIZE}px"\n        container.style.height = f"{self.height * CELL_SIZE}px"\n\n        for z, canvas in enumerate(self.layers.values()):\n            canvas.width = self.width * CELL_SIZE\n            canvas.height = self.height * CELL_SIZE\n            canvas.style.position = "absolute"\n            canvas.style.top = "0px"\n            canvas.style.left = "0px"\n            canvas.style.zIndex = str(z)\n            container.appendChild(canvas)\n \n 第五段：建立控制按鈕並加入畫面 \n 建立兩個按鈕：「前進」與「左轉」。 設定美觀的樣式（內邊距、字體大小等）。 \n         button_container = js.document.createElement("div")\n        button_container.style.marginTop = "10px"\n        button_container.style.textAlign = "center"\n\n        move_button = js.document.createElement("button")\n        move_button.innerHTML = "Move Forward"\n        move_button.style.margin = "5px"\n        move_button.style.padding = "10px 20px"\n        move_button.style.fontSize = "16px"\n        button_container.appendChild(move_button)\n\n        turn_button = js.document.createElement("button")\n        turn_button.innerHTML = "Turn Left"\n        turn_button.style.margin = "5px"\n        turn_button.style.padding = "10px 20px"\n        turn_button.style.fontSize = "16px"\n        button_container.appendChild(turn_button)\n \n \xa0第六段：掛載進 HTML 與按鈕綁定 \n 將畫面掛載到 HTML 中的 brython_div1 元素內。 同時記錄兩個按鈕到 self.move_button、self.turn_button 屬性，以便之後綁定事件 \n         brython_div = js.document.getElementById("brython_div1")\n        if not brython_div:\n            raise RuntimeError("🚨 \'brython_div1\' element not found in HTML!")\n        brython_div.innerHTML = ""\n        brython_div.appendChild(container)\n        brython_div.appendChild(button_container)\n\n        self.move_button = move_button\n        self.turn_button = turn_button\n \n 第七段：繪製地圖網格線（grid） \n 這段程式會畫出地圖的格線，形成棋盤狀的網格。 每格大小為 CELL_SIZE = 40 像素。 格線只是視覺輔助，沒有碰撞作用。 \n     def _draw_grid(self):\n        ctx = self.layers["grid"].getContext("2d")  # 取得網格圖層的繪圖上下文\n        ctx.strokeStyle = "#cccccc"  # 設定線條顏色為淡灰色\n\n        # 垂直線（每列格線）\n        for i in range(self.width + 1):\n            ctx.beginPath()\n            ctx.moveTo(i * CELL_SIZE, 0)\n            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)\n            ctx.stroke()\n\n        # 水平線（每欄格線）\n        for j in range(self.height + 1):\n            ctx.beginPath()\n            ctx.moveTo(0, j * CELL_SIZE)\n            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)\n            ctx.stroke()\n \n 第八段：通用繪圖函式 _draw_image() \n 此函式負責畫圖片在指定格子位置。 需要傳入： \xa0 \xa0 ctx: 要繪製的畫布上下文。 \xa0 \xa0 img_key: 要畫的圖片鍵（例如 "blue_robot_e"）。 \xa0 \xa0 (x, y): 要畫在哪個格子（以地圖邏輯座標為主）。 \xa0 \xa0 (w, h): 圖片的寬與高。 會自動調整畫面位置，將 y 軸上下反轉，使原點在左下角。 \n     def _draw_image(self, ctx, img_key, x, y, w, h, offset_x=0, offset_y=0):\n        img = World._image_cache.get(img_key)\n        if img and img.complete and img.naturalWidth > 0:\n            px = x * CELL_SIZE + offset_x\n            py = (self.height - 1 - y) * CELL_SIZE + offset_y\n            ctx.drawImage(img, px, py, w, h)\n            return True\n        else:\n            print(f"⚠️ Image \'{img_key}\' not ready for drawing.")\n            return False\n \n 第九段：繪製牆壁 _draw_walls() \n 這段會將四周的「邊界牆」畫出來。 利用 _draw_image 畫出 north.png 與 east.png。 offset_x / offset_y 用來對齊圖片位置（不會蓋到格子內）。 \n     async def _draw_walls(self):\n        ctx = self.layers["walls"].getContext("2d")\n        ctx.clearRect(0, 0, self.width * CELL_SIZE, self.height * CELL_SIZE)\n        success = True\n\n        # 繪製上下兩排的北牆（頂部與底部）\n        for x in range(self.width):\n            success &= self._draw_image(ctx, "north", x, self.height - 1, CELL_SIZE, WALL_THICKNESS, offset_y=0)\n            success &= self._draw_image(ctx, "north", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)\n\n        # 繪製左右兩側的東牆（左邊與右邊）\n        for y in range(self.height):\n            success &= self._draw_image(ctx, "east", 0, y, WALL_THICKNESS, CELL_SIZE, offset_x=0)\n            success &= self._draw_image(ctx, "east", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)\n\n        return success\n \n 第十段：預先載入圖片 _preload_images() \n 此函式會載入所有需要用到的圖片（牆壁與機器人朝向圖）。 利用 Promise 建立圖片載入完成的非同步事件，確保載入成功。 透過 await js.await_promise(js.Promise.all(...)) 等待所有圖片載入完畢。 \n     async def _preload_images(self):\n        image_files = {\n            "blue_robot_e": "blue_robot_e.png",\n            "blue_robot_n": "blue_robot_n.png",\n            "blue_robot_w": "blue_robot_w.png",\n            "blue_robot_s": "blue_robot_s.png",\n            "north": "north.png",\n            "east": "east.png",\n        }\n\n        promises = []\n        for key, filename in image_files.items():\n            if key in World._image_cache and World._image_cache[key].complete:\n                continue\n\n            img = js.document.createElement("img")\n            img.crossOrigin = "Anonymous"\n            img.src = IMG_PATH + filename\n            World._image_cache[key] = img\n\n            def make_promise(img_element):\n                def executor(resolve, reject):\n                    def on_load(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        resolve(img_element)\n                    def on_error(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        reject(f"Failed to load image: {img_element.src}")\n                    img_element.addEventListener("load", on_load)\n                    img_element.addEventListener("error", on_error)\n                    if img_element.complete and img_element.naturalWidth > 0:\n                        resolve(img_element)\n                return js.Promise.new(executor)\n\n            promises.append(make_promise(img))\n\n        if not promises:\n            return True\n        try:\n            await js.await_promise(js.Promise.all(promises))\n            return True\n        except Exception as e:\n            print(f"🚨 Error during image preloading: {str(e)}")\n            return False\n \n 第十一段：初始化地圖與資源 setup() \n setup() 是建構完世界後必須呼叫的初始化函式。 包含資源載入、地圖格線與牆壁的繪製。 使用 asyncio.sleep(0) 是一種「讓出主控權給瀏覽器」的技巧，避免卡住畫面。 \n     async def setup(self):\n        # 嘗試三次載入圖片資源，若載入成功則跳出迴圈\n        for _ in range(3):\n            if await self._preload_images():\n                break\n            await asyncio.sleep(0.5)  # 等待 0.5 秒後再試\n        else:\n            print("🚨 Failed to preload images after retries.")\n            return False\n\n        await asyncio.sleep(0)  # 放棄當前事件迴圈執行權，確保 UI 有機會更新\n\n        self._draw_grid()  # 繪製底層的網格\n\n        # 嘗試三次繪製牆壁，等待圖片載入完成\n        for _ in range(3):\n            if await self._draw_walls():\n                break\n            await asyncio.sleep(0.5)\n        else:\n            print("🚨 Failed to draw walls after retries.")\n            return False\n\n        # 最後確認機器人朝向東的圖片是否可用\n        robot_img_key = "blue_robot_e"\n        if not (World._image_cache.get(robot_img_key) and World._image_cache[robot_img_key].complete):\n            print(f"🚨 Robot image \'{robot_img_key}\' still not ready after setup!")\n            return False\n\n        return True  # 所有步驟成功後回傳 True\n \n 第十二段：機器人類別 Robot \n 每個 Robot 物件都有座標與面向，並能畫出自己與移動的軌跡。 傳入 world 是為了能取得地圖的畫布資訊。 \n class Robot:\n    def __init__(self, world, x, y):\n        self.world = world\n        self.x = x - 1  # 將人類習慣的 1-index 轉成 0-index\n        self.y = y - 1\n        self.facing = "E"  # 預設朝東（右邊）\n        self._facing_order = ["E", "N", "W", "S"]  # 左轉時的順序\n\n        self.robot_ctx = world.layers["robots"].getContext("2d")   # 機器人圖層\n        self.trace_ctx = world.layers["objects"].getContext("2d")  # 移動軌跡圖層\n\n        self._draw_robot()  # 初始畫上機器人\n \n _robot_image_key()：依面向回傳圖片鍵 \n 根據面向回傳對應的圖片鍵，例如  E  會回傳  "blue_robot_e" 。 \n     def _robot_image_key(self):\n        return f"blue_robot_{self.facing.lower()}"\n \n _draw_robot()：畫出機器人圖像 \n 先清除原圖，避免留下殘影，再畫上新的機器人圖像。 \n     def _draw_robot(self):\n        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)\n        self.world._draw_image(self.robot_ctx, self._robot_image_key(), self.x, self.y, CELL_SIZE, CELL_SIZE)\n \n _draw_trace()：畫出移動路徑 \n 此方法畫出機器人從起點到終點的直線軌跡。 \n     def _draw_trace(self, from_x, from_y, to_x, to_y):\n        ctx = self.trace_ctx\n        ctx.strokeStyle = "#d33"  # 紅色線條\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        fx = from_x * CELL_SIZE + CELL_SIZE / 2\n        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2\n        tx = to_x * CELL_SIZE + CELL_SIZE / 2\n        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2\n        ctx.moveTo(fx, fy)\n        ctx.lineTo(tx, ty)\n        ctx.stroke()\n \n 第十三段：機器人行走與轉彎 \n walk(steps)：前進 \n 根據面向方向更新位置，並畫出移動。 超出地圖邊界時停止。 \n     async def walk(self, steps=1):\n        for _ in range(steps):\n            from_x, from_y = self.x, self.y\n            dx, dy = 0, 0\n            if self.facing == "E": dx = 1\n            elif self.facing == "W": dx = -1\n            elif self.facing == "N": dy = 1\n            elif self.facing == "S": dy = -1\n\n            next_x = self.x + dx\n            next_y = self.y + dy\n\n            if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:\n                self.x, self.y = next_x, next_y\n                self._draw_trace(from_x, from_y, self.x, self.y)\n                self._draw_robot()\n                await asyncio.sleep(0.2)\n            else:\n                print("🚨 Hit a wall, stop moving!")\n                break\n \n turn_left()：左轉 \n 從目前面向向左轉一格，更新圖片。 \n     async def turn_left(self):\n        idx = self._facing_order.index(self.facing)\n        self.facing = self._facing_order[(idx + 1) % 4]  # 循環轉向\n        self._draw_robot()\n        await asyncio.sleep(0.3)\n \n 第十四段：綁定控制 _bind_controls(robot) \n 定義一個私有方法，將控制行為綁定給特定 robot 實例。 \n def _bind_controls(robot: Robot):\n \n 鍵盤控制 \n 設定 j → 前進，i → 左轉。 使用 asyncio.create_task() 以非同步方式執行，避免卡住主執行緒。 \n     def handle_key(event):\n        try:\n            if event.key == \'j\':\n                asyncio.create_task(robot.walk(1))     # 按下 j 移動一步\n            elif event.key == \'i\':\n                asyncio.create_task(robot.turn_left()) # 按下 i 左轉\n        except Exception as e:\n            print(f"🚨 Error in key handler: {e}")\n \n 按鈕點擊控制 \n 這兩個函式綁定到 UI 裡的按鈕（前面 _init_html() 中定義的）。 功能與鍵盤控制一樣，只是透過滑鼠點擊。 \n     def handle_move_button(event):\n        try:\n            asyncio.create_task(robot.walk(1))\n        except Exception as e:\n            print(f"🚨 Error in move button handler: {e}")\n\n    def handle_turn_button(event):\n        try:\n            asyncio.create_task(robot.turn_left())\n        except Exception as e:\n            print(f"🚨 Error in turn button handler: {e}")\n \n 註冊事件到 JavaScript \n 將 handle_key() 註冊為全域 py_handle_key，讓 JavaScript 層級可以呼叫 Python。 \n 將按鈕的點擊事件對應到 Python 定義的控制函式。 \n     js.window.py_handle_key = handle_key\n    js.document.addEventListener(\'keydown\', js.Function("event", "py_handle_key(event);"))\n    js.window.py_handle_move_button = handle_move_button\n    js.window.py_handle_turn_button = handle_turn_button\n    robot.world.move_button.addEventListener(\'click\', js.Function("event", "py_handle_move_button(event);"))\n    robot.world.turn_button.addEventListener(\'click\', js.Function("event", "py_handle_turn_button(event);")) \n 第十五段：初始化並啟動 init() \n 提供一個使用者簡單快速初始化整個世界與機器人的介面。 \n def init(world_width=10, world_height=10, robot_x=1, robot_y=1):\n \n 包裝為非同步任務 \n 這個包裝函式 async def _inner() 是用來實作內部非同步邏輯。 \n     async def _inner():\n        world = World(world_width, world_height)  # 建立世界\n        if not await world.setup():               # 等待世界初始化完成\n            raise RuntimeError("World setup failed!")  # 若失敗則丟出錯誤\n\n        robot = Robot(world, robot_x, robot_y)    # 建立機器人\n        _bind_controls(robot)                     # 綁定控制事件\n        return world, robot                       # 傳回 world 和 robot 物件\n \n 建立並啟動非同步任務 \n     return asyncio.create_task(_inner())\n \n 回傳一個非同步任務（asyncio.Task），讓使用者可以這樣呼叫： \n world, robot = await init(10, 10, 1, 1)\n \n 等待 init() 的結果後，就可以直接控制 robot.walk() 或 robot.turn_left()。 \n', 'tags': '', 'url': 'robot.py.html'}, {'title': 'Example2', 'text': '自行定義機器人右轉的非同步執行函式: \n 執行 turn_right 程式 範例。 \n import robot\nimport asyncio\n\n# 定義右轉的非同步函式\nasync def turn_right(bot):\n    for _ in range(3):\n        await bot.turn_left()\n\nasync def main():\n    world, bot = await robot.init(10, 10, 1, 1)\n    print("機器人開始行動")\n    await bot.turn_left()\n    await bot.walk(9)\n    await turn_right(bot) \n    print("機器人完成行動")\n\n# main() 讓出執行控制權，由頁面中的 even loop 決定何時執行 main()\nawait main()\n \n', 'tags': '', 'url': 'Example2.html'}, {'title': 'Pyodide3', 'text': 'Pyodide3 則在  Pyodide  與  Pyodide2  頁面架構下，進一步導入  robot_w_world.py ，在既有的水平圍牆  north.png  與垂直圍牆  east.png  檔案之外，加入  carrot.png 、 grass.png  與  pale_grass.png  等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。 \n 其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自  Reeborg  機器人程式所設定的 json 格式場景。 \n 由於 Reeborg 系統中的 png 圖檔均非透明背景， robot_w_world.py \xa0必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。 \n src URL 變數讀進  turn_right 程式 ，而 world URL 變數則讀進  harvest2.json ，執行 結果 。 \n 讀進  harvest3.json , 執行 結果 。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide3.html'}, {'title': 'png_files', 'text': '利用  robot_w_world.py  將 png 圖檔實踐「關鍵色透明」: 作法是在程式碼中額外添加像素處理的邏輯。Canvas 的 drawImage 方法本身不會自動識別並跳過特定顏色的像素，所以我們必須手動介入。 處理方法: 要讓  robot_w_world.py  實現這個功能，必須修改 _draw_image 方法，或者在圖片載入後進行預處理。最直接的方法是在繪製數字圖片時，讀取其像素數據，並將特定顏色（例如白色）的像素的 Alpha 值設置為 0。 這會涉及以下步驟： \xa0 \xa0 取得圖片像素資料： 將圖片繪製到一個臨時的、看不見的 Canvas 上。 \xa0 \xa0 讀進所有像素： 讀取這個臨時 Canvas 的像素資料。 \xa0 \xa0 修改像素的 Alpha 值： 檢查每個像素的 RGB 值，如果它符合預設的「關鍵色」（例如，純白色 (255, 255, 255)），就將其 Alpha (透明度) 值設為 0。 \xa0 \xa0 將修改後的像素資料放回： 將修改後的像素資料重新放回臨時 Canvas。 \xa0 \xa0 繪製臨時 Canvas： 最後，將這個處理過的臨時 Canvas 繪製到我們實際要顯示的圖層上。 缺點與考量: \xa0 \xa0 性能影響： 像素級的處理是相對耗費資源的，特別是當有很多數字需要顯示時。這可能會導致動畫或初始加載時出現輕微的延遲。 \xa0 \xa0 複雜性增加： 程式碼會變得更複雜，需要處理 Canvas API 的 getImageData 和 putImageData 方法。 \xa0 \xa0 關鍵色選擇： 您需要確定一個所有數字圖片背景都一致的「關鍵色」。如果有些數字圖片背景是白色，有些是淺灰色，這個方法就會失效。 \n', 'tags': '', 'url': 'png_files.html'}, {'title': 'Harvest', 'text': 'Pyodide3  在頁面中導入  robot_w_world.py \xa0後，可以透過\xa0 pyodide3_harvest_ex1.py \xa0繼承 robot 物件，加入農作物採收功能。 \n 但因為\xa0 robot_w_world.py \xa0版本中的 trace 繪製圖層並未獨立，除了採收農作物之後的座標背景會從 pale_grass.png 置換為 grass.png 外，農作物採收後的座標畫面刷新會一併將之前的機器人行走路徑刪除，因此後續版本必須將所有不同屬性的圖像，以各自的獨立圖層進行繪製，才不會互相影響下，產生錯誤的機器人農作物採收模擬。 \n 在 Pyodide3 執行\xa0 pyodide3_harvest_ex1.py ，執行 結果 。 \n', 'tags': '', 'url': 'Harvest.html'}]};