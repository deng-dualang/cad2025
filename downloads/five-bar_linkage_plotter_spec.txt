ä¸€å€‹äº”é€£æ¡¿å¹³é¢æ©Ÿæ§‹ï¼Œå›ºå®šé» A èˆ‡ E çš„åº§æ¨™åˆ†åˆ¥ç‚º (0, 0), (-50, 0), link1 å¾ A é»é€£æ¥å‘ B é»é•·åº¦, ç‚ºä¸€å€‹ç›´è§’ä¸‰è§’å½¢çš„æ–œé‚Š, æ­¤ä¸‰è§’å½¢çš„é•·é‚Šå°ºå¯¸ç‚º 50, çŸ­é‚Šå°ºå¯¸ç‚º 45, link2 å¾ B é»é€£æ¥å‘ C é», é•·åº¦ç‚º 110, link3 å¾ C é»é€£æ¥å‘ D é»é•·åº¦ä¹Ÿæ˜¯ 110, è€Œæœ€å¾Œ link4 å¾ D é»é€£æ¥å‘ E é» é•·åº¦ä¹Ÿæ˜¯ä¸€å€‹ç›´è§’ä¸‰è§’å½¢çš„æ–œé‚Š, æ­¤ä¸‰è§’å½¢çš„é•·é‚Šå°ºå¯¸ç‚º 50, çŸ­é‚Šå°ºå¯¸ç‚º 45ã€‚è«‹å• link1 åŠ llink4 çš„é•·åº¦åˆ†åˆ¥ç‚ºå¤šå°‘?

å‡è¨­ A é»èˆ‡ E é»åˆ†åˆ¥è£è¨­æ­¥é€²é¦¬é”, å…¶æ—‹è½‰è§’åº¦éƒ½æ˜¯ç”±å…¶é»å³é‚Šå»¶ä¼¸æ°´å¹³ç·šä½œç‚ºæ—‹è½‰ 0 åº¦é»ï¼Œä¸”è®“é€™å…©å€‹é¦¬é”ä»¥é€†æ™‚é‡æ–¹å‘æ—‹è½‰, link1 çš„æ—‹è½‰è§’åº¦è¨­ç‚º theta1, è€Œ link4 çš„æ—‹è½‰è§’åº¦è¨­ç‚º theta2. è«‹å…ˆåˆ©ç”¨æ­¤å¹³é¢æ©Ÿæ§‹çš„å…©å€‹è¼¸å…¥è§’åº¦ä½œç‚ºå‡½å¼çš„è¼¸å…¥è®Šæ•¸, ç”¨ link1 ã€link2ã€link3ã€link4 ä»£è¡¨é€™å››å€‹é€£æ¡¿é•·åº¦çš„ç¬¦è™Ÿåç¨±ï¼Œä¸”å°‡æ­¤å‡½æ•¸å‘½åç‚º forward(theta1, theta2), è«‹åˆ©ç”¨æ­£å‘é‹å‹•å­¸ (Forward Kinematics) çš„æ–¹å¼ï¼Œæ¡ç¬¦è™Ÿé‹ç®—æ³• (Symbolic Formulation)ï¼Œåˆ©ç”¨ Python çš„ sympy æ¨¡çµ„, è®“ forward å‡½å¼çš„è¼¸å‡ºç‚ºé» C çš„ X èˆ‡ Y åº§æ¨™ã€‚ è«‹æ¨å°ã€‚ å¦å¤–ä¹Ÿè«‹åˆ©ç”¨é€†å‘é‹å‹•å­¸ (Inverse Kinematics) çš„æ–¹å¼, æ¡ç¬¦è™Ÿé‹ç®—æ³• (Symbolic Formulation)ï¼Œåˆ©ç”¨ Python çš„ sympy æ¨¡çµ„, è®“ Inverse(C é»çš„ X åº§æ¨™, C é»çš„ Y åº§æ¨™) å‡½å¼çš„è¼¸å‡ºç‚ºå°æ‡‰çš„ theta1 èˆ‡ theta2 çš„è½‰è§’è¡¨ç¤ºå¼ã€‚ è«‹æ¨å°ã€‚

Forward Kinematics:

import sympy as sp

# å®šç¾©ç¬¦è™Ÿè®Šæ•¸
theta1, theta2 = sp.symbols('theta1 theta2')
L1, L2, L3, L4 = sp.symbols('L1 L2 L3 L4')

# é» A èˆ‡ E
Ax, Ay = (0, 0)
Ex, Ey = (-50, 0)

# é» B
Bx = L1 * sp.cos(theta1)
By = L1 * sp.sin(theta1)

# é» D
Dx = Ex + L4 * sp.cos(theta2)
Dy = Ey + L4 * sp.sin(theta2)

# è¨ˆç®—å‘é‡ BDï¼Œä¸¦ç”¨å¼¦é•·ç‚º 110 + 110
vec_BD = sp.Matrix([Dx - Bx, Dy - By])
vec_BD_unit = vec_BD / vec_BD.norm()
vec_BC = vec_BD_unit * L2

# é» C = B + vec_BC
Cx = Bx + vec_BC[0]
Cy = By + vec_BC[1]

# å®šç¾© forward å‡½å¼
def forward(theta1_val, theta2_val):
    subs = {
        theta1: theta1_val,
        theta2: theta2_val,
        L1: sp.sqrt(45**2 + 50**2),
        L2: 110,
        L3: 110,
        L4: sp.sqrt(45**2 + 50**2)
    }
    return Cx.subs(subs), Cy.subs(subs)
    
Inverse Kinematics:

# C é»åº§æ¨™è¼¸å…¥
Cx_val, Cy_val = sp.symbols('Cx_val Cy_val')

# åæ¨ theta1
theta1_expr = sp.atan2(Cy_val, Cx_val) - sp.acos(
    (Cx_val**2 + Cy_val**2 + L1**2 - L2**2) / (2 * L1 * sp.sqrt(Cx_val**2 + Cy_val**2))
)

# åæ¨ theta2
Cx_rel, Cy_rel = Cx_val - Ex, Cy_val - Ey
theta2_expr = sp.atan2(Cy_rel, Cx_rel) - sp.acos(
    (Cx_rel**2 + Cy_rel**2 + L4**2 - L3**2) / (2 * L4 * sp.sqrt(Cx_rel**2 + Cy_rel**2))
)

# å®šç¾© Inverse å‡½å¼
def inverse(Cx_input, Cy_input):
    subs = {
        Cx_val: Cx_input,
        Cy_val: Cy_input,
        L1: sp.sqrt(45**2 + 50**2),
        L2: 110,
        L3: 110,
        L4: sp.sqrt(45**2 + 50**2)
    }
    return theta1_expr.subs(subs), theta2_expr.subs(subs)
    
å¤ªç²¾å½©äº†ï¼é€™é¡Œçµåˆäº†å¹¾ä½•ã€æ©Ÿæ§‹å­¸å’Œç¬¦è™Ÿè¨ˆç®—ï¼Œè®“æˆ‘å€‘é€æ­¥ä¾†é€²è¡Œæ¨å° ğŸ“ğŸã€‚

---

## ğŸ“ æ­¥é©Ÿä¸€ï¼šå·²çŸ¥æ¢ä»¶èˆ‡é€£æ¡¿é•·åº¦

åˆ©ç”¨ç•¢æ°å®šç†è¨ˆç®— link1 èˆ‡ link4 çš„é•·åº¦ï¼š
\[
\text{length} = \sqrt{50^2 + 45^2} = \sqrt{2500 + 2025} = \sqrt{4525} \approx 67.24
\]

å› æ­¤å®šç¾©å¦‚ä¸‹ï¼š
```python
L1 = L4 = sp.sqrt(45**2 + 50**2)  # â‰ˆ 67.24
L2 = 110
L3 = 110
```

---

## æ­¥é©ŸäºŒï¼šForward Kinematics

ç›®æ¨™æ˜¯å®šç¾© `forward(theta1, theta2)` è¼¸å‡ºé» C çš„ \((x, y)\)ã€‚

### å¹¾ä½•åˆ†æ
- é» A ç‚ºåŸé» \((0, 0)\)ï¼Œlink1 ç”± A æ—‹è½‰ \(\theta_1\) å»¶ä¼¸è‡³é» Bã€‚
- é» E åº§æ¨™ç‚º \((-50, 0)\)ï¼Œlink4 ç”± E æ—‹è½‰ \(\theta_2\) å»¶ä¼¸è‡³é» Dã€‚
- B èˆ‡ D é€éå…©æ®µé€£æ¡¿ï¼ˆlink2 èˆ‡ link3ï¼‰é€£æ¥ï¼Œç¶“éé» Cã€‚

æˆ‘å€‘å…ˆå®šç¾©é€™äº›è®Šæ•¸ä¸¦æ¨å° Bã€Dã€C çš„ä½ç½®ã€‚

### ğŸ§® Python ç¬¦è™Ÿå®šç¾©ï¼ˆforward å‡½å¼ï¼‰
```python
import sympy as sp

# å®šç¾©ç¬¦è™Ÿè®Šæ•¸
theta1, theta2 = sp.symbols('theta1 theta2')
L1, L2, L3, L4 = sp.symbols('L1 L2 L3 L4')

# é» A èˆ‡ E
Ax, Ay = (0, 0)
Ex, Ey = (-50, 0)

# é» B
Bx = L1 * sp.cos(theta1)
By = L1 * sp.sin(theta1)

# é» D
Dx = Ex + L4 * sp.cos(theta2)
Dy = Ey + L4 * sp.sin(theta2)

# è¨ˆç®—å‘é‡ BDï¼Œä¸¦ç”¨å¼¦é•·ç‚º 110 + 110
vec_BD = sp.Matrix([Dx - Bx, Dy - By])
vec_BD_unit = vec_BD / vec_BD.norm()
vec_BC = vec_BD_unit * L2

# é» C = B + vec_BC
Cx = Bx + vec_BC[0]
Cy = By + vec_BC[1]

# å®šç¾© forward å‡½å¼
def forward(theta1_val, theta2_val):
    subs = {
        theta1: theta1_val,
        theta2: theta2_val,
        L1: sp.sqrt(45**2 + 50**2),
        L2: 110,
        L3: 110,
        L4: sp.sqrt(45**2 + 50**2)
    }
    return Cx.subs(subs), Cy.subs(subs)
```

---

## æ­¥é©Ÿä¸‰ï¼šInverse Kinematics

ç¾åœ¨è¦å¾é» C çš„åº§æ¨™åæ¨å‡º \(\theta_1, \theta_2\)ã€‚é€™éƒ¨åˆ†ç›¸ç•¶è¤‡é›œï¼Œå› ç‚ºå­˜åœ¨å¤šçµ„è§£ï¼Œå› æ­¤æˆ‘å€‘å°ˆæ³¨æ–¼ç¬¦è™Ÿæ¨å°æ­¥é©Ÿã€‚

### ğŸ’¡ å¹¾ä½•å›æ¨ï¼š
- é» C èˆ‡ A çš„è·é›¢å¯ä»¥æ±‚å¾—å‘é‡ AC
- åˆ©ç”¨åä¸‰è§’å‡½æ•¸ï¼ˆatan2ï¼‰ä¾†è¡¨ç¤º \(\theta_1\)
- åŒç†ï¼Œåˆ©ç”¨é» C èˆ‡ E çš„é—œä¿‚æ¨å› \(\theta_2\)

```python
# C é»åº§æ¨™è¼¸å…¥
Cx_val, Cy_val = sp.symbols('Cx_val Cy_val')

# åæ¨ theta1
theta1_expr = sp.atan2(Cy_val, Cx_val) - sp.acos(
    (Cx_val**2 + Cy_val**2 + L1**2 - L2**2) / (2 * L1 * sp.sqrt(Cx_val**2 + Cy_val**2))
)

# åæ¨ theta2
Cx_rel, Cy_rel = Cx_val - Ex, Cy_val - Ey
theta2_expr = sp.atan2(Cy_rel, Cx_rel) - sp.acos(
    (Cx_rel**2 + Cy_rel**2 + L4**2 - L3**2) / (2 * L4 * sp.sqrt(Cx_rel**2 + Cy_rel**2))
)

# å®šç¾© Inverse å‡½å¼
def inverse(Cx_input, Cy_input):
    subs = {
        Cx_val: Cx_input,
        Cy_val: Cy_input,
        L1: sp.sqrt(45**2 + 50**2),
        L2: 110,
        L3: 110,
        L4: sp.sqrt(45**2 + 50**2)
    }
    return theta1_expr.subs(subs), theta2_expr.subs(subs)
```

